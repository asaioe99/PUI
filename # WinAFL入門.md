# 仕事のためのFuzzing入門
本解説は、仕事のためにFuzzingについて学ぶ必要のある人のために、取り急ぎ最低限の知識を身に着けるためのものである。その中でも特に、管理者と実務担当者を対象としており、実務担当者は本解説の各タイトルに〇印がある部分を、そして管理者は△印のある部分を拾い読みすれば良い。

この解説だけでは完結しない知識もあるので、その部分については参考文献を載せているので参照して頂きたい。また、管理者については実際にFuzzingを実施する訳ではないので、主に必要な環境や整えておくべき人材、更に機材や人材を評価する観点について説明する。

また、実務担当者の業務手順習得のために、実在するアプリケーション（JWCAD：CAD用のフリーソフト）に対してFuzzingを行う。そして、そのために必要な環境構築についても一通り解説する。

# Fuzzingの原理〇△
Fuzzingを行う目的は、対象のアプリケーションから脆弱性を自動的に検出することである。ここで言う脆弱性とは、不正なメモリアクセスや無限ループ（ hang）を誘起するような入力（以下「不正な入力」という）として発見される。

つまり、今回体験するJWCADに対するFuzzingの場合、JWCADに対して様々なファイルを読み込ませ、その中からJWCADに対して不正なメモリアクセスや無限ループを引き起こすようなファイルを発見するのである。

## 不正な入力を発見する方法〇
恐らく疑問を持った方も多いだろうが、不正な入力を発見する方法は一見して明らかではない。例えば、総当たりで全てのbitパターンを調査する方法が思いつく。この方法であれば、原理的には全ての不正な入力を発見できそうである。しかしながら、現実的な時間ではこの計算を終えることができないので、より効率的な方法を考える必要がある。

### 正規の入力を壊す〇
最初に思いつく方法は、元々正常な読み込みのできるファイルや入力を少しだけ変更する方法である。これには一応の理屈があって、

- いきなりランダムな入力を使うと、parserに弾かれる
- bit反転や延長で、入力値を気軽に変化させられる

というものである。

実際、これは悪くない戦略である。例えば、入力データ内のある部分が、その入力データのサイズを表していた場合、その部分の一部のbitを反転させると、本来のファイルサイズとは異なる値になってしまう。その場合、対象のアプリケーションに対策がさせていなければ、本来のデータサイズを超えた領域までアクセスしてデータを読み取ろうとしてしまうことが一応は予想される。

その結果、不正なメモリアクセスを行ってしまうかも知れない。また、入力された値に応じて、読み込みではなく書き込みを行うのであれば、特定のメモリ領域に対して意図した値を書き込めるかも知れない。そうすれば、何らかの悪意のあるコードを実行できるかも知れないのである。

上手く本来の入力の一部だけを壊すことにより、parserの目を誤魔化しつつも不正な操作を行える可能性がある。そして実際に、この戦略に似たものがWinAFLによるFuzzingで```bit flips```や```byte flips```という名称として採用されている。

### メモリに明かりを灯す〇
他にも戦略がある。例えば、もしもメモリ（厳密にはtextセクション）のどの部分を実行しているか、その実行している箇所が光ったとしよう。そして更に、実行した部分はそのまま光り続けたとする。

その様な場合、プログラムを実行した場合、entryポイントから順に明かりが灯り、そして条件分岐によって実行箇所が飛んだ場合は、その先から同じように明かりが灯ることになる。最終的にプログラムが終了するまでに実行された部分は全て明かりが灯るが、例えば条件分岐により飛ばなかった部分は暗いままである。

これが何を意味しているかはそれほど明らかではない。しかし、もし本来コードとして実行されることを想定しない領域（データ領域）に明かりが灯ったら面白いはずである。つまり、入力したデータの何らかの作用により、本来想定されていない動作が生じた可能性が高い。

つまり、何らかの方法によってメモリに明かりを灯すことができれば、メモリの明るい部分の範囲（covarage：カバレッジ）の広さにより、脆弱性を生じさせ易さを計測することができそうである。

### 実際の方法〇
実際にはメモリに明かりを灯すことは困難であるので、より簡単な方法を採用している。例えば、我々が観測したいのは実行されたことのあるメモリの範囲であり、それを調べるだけであれば、条件分岐の部分だけを観測しておけばよい。つまり、トンネルの入り口と出口だけを監視していれば、トンネルの内部まで車を追わなくても良いのである。

そこで、実際の方法としては、このトンネルの入り口に相当する部分に対して、そこを通過したことを観測する特殊なコードを仕組んでプログラムを実行している。この特殊なコードというのは単なるジャンプ命令であり、トンネルの入り口で一度別の部分に車を誘導し、そこで車両が通過したことを記録した上で、再度トンネルの入り口に戻しているだけである。

これは例え話であるが、実際の場面ではバイナリ計装と呼ばれる考え方である。そして、ソースコードを書き換えて計装（instrumentation：インストラメンテイション）する場合と、実行中のプログラムに対して計装する方法があり、順に静的/動的バイナリ計装と呼ぶ。

そして、計装によりカバレッジを大きくするように入力を変化させることで、不正な入力を発見することができる。本解説では、カバレッジ拡大を目指す上で、どの様に入力を変化させるかについては説明しないが、念のために参考文献を示す。

参考：探しておきます

### 必要な時間〇△
これまでの説明で、不正な入力を発見するための考え方について説明した。問題は、どのくらいの時間をかけてFuzzingを行えば脆弱性を検出できるかである。結論から言えば、必要な時間は予測不可能である。解析対象のアプリケーションが一切脆弱性の存在しない完璧なものであれば、当然無限に時間をかけても発見することはできない。反対に脆弱性の塊の様なアプリケーションであれば、Fuzzing開始と同時に堰を切ったかの様に脆弱性が発見される。そしてこれらは、解析に利用するコンピュータの性能に大きく依存する。

そのため、どれくらい時間が必要かを見積もることよりも、どれくらいの時間で脆弱性が発見されたかで判断すべきである。つまり、高性能なコンピュータによる１ヶ月間ものFuzzingにより、一つも脆弱性が発見されなかったのであれば、それは相当に堅牢なアプリケーションであり、これを攻撃する者達も少なくともこれと同じ以上の解析費用を必要とする。

また、攻撃者としての視点に立てば、対象のアプリケーションを自由に選ぶことのできない状況であれば、如何なるコストを支払ってでもFuzzingを継続し、脆弱性を何としてでも発見しなければならない。結果的に発見できない可能性もある訳で、もし時間的制約があるのであれば、一定の基準を定め、その時間内に成果を出せなければ打ち切る必要がある。

### 必要なコンピュータの性能〇△
今までの話から単純に論じれば、コンピュータの性能が倍になれば、同じ時間で発見できる脆弱性の数も倍になりそうに思える。これはある程度は事実であるが、注意点もある。

ここで押さえておきたいことは、単純に発見した不正な入力の数を評価してはならないということである。重要なのは種類である。つまり、プログラム中の同じ脆弱性に対して作用する不正な入力を作るだけなら、実はいくらでも数を増やすことができてしまうのであり、本来評価すべきなのはプログラム中に存在する脆弱性をいくつ発見したかである。この事実は必ず押さえておく必要がある。そして発見可能な脆弱性の種類は、使用するFuzzerや解析者の能力にも依存している。そのため、厳密な議論は困難である。

さて、以上を理解した上で、それでもコンピュータの性能が重要であることを強調しよう。そして、以下の様な点に注意して導入するコンピュータを決定すべきである。

- コア数が多い
- メモリのサイズが大きい
- 高速に読み書きできる不揮発性記憶媒体（SSD）を使用している
- 堅牢で信頼性が高い
- 突然の停電等にも対応できる電源を有している

## 不正な入力を発見したら
今までに説明した様々な方法により、メモリアクセス違反や無限ループを引き起こすような入力を発見した場合、次に行うのは、入力したデータのどの部分がプログラムのどの部分に作用して不正な動作を引き起こしたかを解析することである。

この解析を行うのに必要な技術は以下の通りである。

- C/C++言語の実用的な技術
- 


それでは、具体的にどの様な場合に脆弱性が引き起こされるかについて説明する。


https://www.ipa.go.jp/security/awareness/vendor/programmingv2/cc01.html

## 文字列コピー
最も有名なものに、


# WinAFL入門

## 必要なものリスト
- WinAFL

   https://github.com/googleprojectzero/winafl
   
   Fuzzingの対象によっては、自分でソースコードを修正して都度ビルドする必要がある。

- DynamoRIO-Windows-8.0.18460

   https://github.com/DynamoRIO/dynamorio/releases/tag/cronbuild-8.0.18460

   DynamoRioはビルドせずにそのままbin32/64を使用

- Visual Studio Community 2017 (version 15.9)

   https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads

   WinAFLのビルドに使用

- JWCAD　(ver8.24a)

   https://www.jwcad.net/download.htm

   今回の解析対象

- Ghidra 10.1.2

   https://github.com/NationalSecurityAgency/ghidra/releases/tag/Ghidra_10.1.2_build

   JWCADを解析し、```target_offset```を選定するために使用

- WinDbg Preview

   https://www.microsoft.com/ja-jp/p/windbg/9pgjgd53tn86?SilentAuth=1&wa=wsignin1.0&rtc=1&activetab=pivot:overviewtab

   JWCADを解析し、```target_offset```を選定するために使用




## DynamoRioの準備
DynamoRioは、

 