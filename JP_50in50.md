# 50CVEを50日間で　-Adobe Readerをファジング-

2018年12月12日（木）

Research By: ヨアヴ・アロン、ネタネル・ベンシモン

## はじめに

2017年は、脆弱性をめぐる状況の転換点であった。この年に報告された新たな脆弱性の数は約14,000件で、前年の2倍以上である（下表参照）。この理由として考えられるのは、「ファザー」とも呼ばれる自動脆弱性発見ツールの普及が進んだことである。

![fig1-1](https://user-images.githubusercontent.com/77034428/163527737-60d6a7a9-b2be-4fac-a75e-72adcd637122.png)

ファザーの存在自体は、20年以上前からあるもので、決して新しいものではない。しかし、ファザーが成長したことは事実である。より高性能になり、より身近になり、全体的に成熟してきたのである。しかし、ファザーを使うことは「ダークアート」と呼ばれ、多くの研究者はファザーを使うのが面倒だと考え、手を出さないのが現状である。

以上のことを踏まえれば、我々は当然問うべきである。「ファザーを使ってより多くの脆弱性を発見する研究者が増えている。しかし、すべての研究者がファザーを使い、すべての脆弱性を見つけているのだろうか？　「FUZZ」と書かれた大きなボタンを押す者を待っている、収穫を待つ実り豊かな果実がどれだけあるのだろうか？」

それを確かめるために、私たちは思いつく限りの最もありふれた実験を組み立てた。最も一般的なWindowsファジングフレームワークの1つであるWinAFLを使用し、世界で最も人気のあるソフトウェア製品の1つであるAdobe Readerをターゲットにした。コードのリバースエンジニアリング、脆弱性のあるライブラリの探索、ハーネスの作成、そして最後にファザーの実行まで、すべての作業に50日という期間を設定した。

その結果に私たちは驚かされた。この50日間で、Adobe Readerに50以上の新しい脆弱性を発見することができたのである。平均すると1日に1件の脆弱性が発見されたことになり、この種の調査としてはかなり異例なペースである。

本論文では、この研究の全貌を明らかにする。検索範囲を拡大するために用いた新しい方法論、WinAFLに施した改良、そして最終的に得られた洞察について紹介する。

## WinAFLとはなにであるか？

AFLはカバレッジガイド付き遺伝的ファザーであり、強固な実装と巧妙な発見的手法により、実際のソフトウェアのバグの発見に成功していることが良く実証されている。

WinAFLは、Ivan Fratric (Google Project Zero)によって作成・維持されているWindows用のAFLのフォークである。Windows版では、クローズドソースのバイナリを標的にできるように、異なる方式の計装を使用している。

AFLの仕組みについて詳しく書かれている[AFLの技術文書](https://github.com/google/AFL/blob/master/docs/technical_details.txt)を読むことを推奨する。それにより、このツールの欠点を把握し、不具合が生じた際のデバッグに役立つはずだ。

また、WinAFLが特に圧縮されたバイナリ形式（画像/ビデオ/アーカイブ）のファイルフォーマットのバグを見つけることに対し、非常に効果的であることが知られている。

## Acrobat Reader DCを攻撃する
最も簡単なのは、メインの実行ファイルであるAcroRd32.exeから始めることである。これは、約30MBの大きさのAcroRd32.dllの（比較的）薄いラッパーである。AcroRd32.dllには多くのコードがあり、その中にはPDFオブジェクトのパーサーも含まれているが、多くはGUIに関連するコードである（通常バグを探したい部分ではない）。

WinAFLはバイナリ形式の方が得意であるため、特定のパーサーを攻略することに注力した。課題は、パーサーの場所を特定し、そのためのハーネスを書くことである。ハーネスとは一体何なのかについては、後ほど説明する。

我々は、Acrobat Reader DC プロセス全体をロードすることなくロードできる、最小限の依存関係を持つバイナリ形式のパーサーを見つけたい。そこでAcrobatのフォルダにあるDLLを探索したところ、JP2KLib.dllがすべてのカテゴリーに該当することが判明した。

![fig2-1](https://user-images.githubusercontent.com/77034428/163533147-6b88b2ab-06e9-4bdf-b0d9-45a6a905a7ba.png)

JP2KLib.dll は、複雑なバイナリ形式である JPEG2000 形式のパーサーで (753 KB)、シンボル名が説明的な関数がエクスポートされていることが分かる。

![fig3](https://user-images.githubusercontent.com/77034428/163536452-0623c9d3-843e-4487-b81e-11f74efccda8.jpg)

調査は以下のバージョンで実施

Acrobat Reader DC 2018.011.20038 およびそれ以前

JP2KLib.dll バージョン 1.2.2.39492

※訳注：dllエクスポート関数のシンボル名は必ずしも残っているわけではない。また確認する際は、Dependency Walkerのリメイクである[Dependencies](https://github.com/lucasg/Dependencies)を使用することを推奨する

## 目的関数とは

目的関数とは、WinAFLがファジングプロセスのエントリポイントとして使用する関数を表す用語である。この関数は、fuzz_iterationsの回数だけループで呼び出され、そのたびにディスク上の入力ファイルを変異させる。目的関数は必ず、


- 入力ファイルを開き、ファイルを読み、入力をパースし、ファイルを閉じる
- C++の例外を投げたり、TerminateProcessを呼び出したりすることなく、正常に終了する

という条件を満たす必要がある。

しかしながら、この条件を満たす関数が存在することは、かなり珍しいことである。特に、複雑なソフトウェアをターゲットにする場合、通常はハーネスを書く必要がある。

## ハーネスとは何か

ハーネスとは、ファジングしたい機能を起動するための最小限のプログラムである。ハーネスには、目的関数として使用する関数が含まれていなければならない。以下は[WinAFLリポジトリにあるgdiplus](https://github.com/googleprojectzero/winafl/blob/master/gdiplus.cpp
)のための最小限のハーネスの例である。

![fig4-1](https://user-images.githubusercontent.com/77034428/163541656-5d35ebd0-7f4b-411a-a18f-a9fd3ac47539.png)

mainの第一引数はパスである。この関数の中で Image::Image パーサを呼び出しているが、これは我々がファジングしたい対象の API になっている。また、エラー時にプロセスを終了させず、最後にすべてのリソースを解放していることに注意してほしい。

文書化されたいるAPIの場合、この作業は比較的容易である。サンプルコードをコピーしたり、文書を参照して簡単なプログラムを書いたりすることができる。しかし、それのどこに面白さがあるのだろうか。

今回は、クローズドソースのバイナリであるAdobe Readerをターゲットに選択した。この種のターゲットに対するハーネスの書き方は、次の様になる。

1. ファジングする機能を探す
2. リバースエンジニアリングする
3. リバースエンジニアリングしたAPIを呼び出すプログラムを書く
4. 完全に機能するハーネスができるまで繰り返す

以下では、JP2KLibをリバースエンジニアリングし、動作するハーネスを作成した方法について詳しく説明する。また、いくつかヒントも紹介する。ファジングの方法論にしか興味のない読者は、次のセクションを読み飛ばしても構わない。

※訳注：当然読み飛ばしてはならないはずである

## JP2KLib.dll 用のハーネスを書く

JP2KLib.dllのリバースエンジニアリングを始める前に、そのライブラリがオープンソースであるか、公開されているシンボル情報があるかどうかをチェックした。これにより大きく時間節約をすることができるが、これは読者がが思っているよりも一般的な作業である。しかしながら、我々の場合、それほど運に恵まれてはいなかった。

我々のハーネスはAdobe ReaderがJP2KLibを使用する時の動作と可能な限り同じにしたかったため、最初にしなければならなかったことは、我々がファジングしたい動作を引き起こすPDFファイルを見つけることであった。これにより、プログラムの関連部分を簡単に探し出すことができる。

我々の場合、製品のテスト用に大量のPDFのコーパスが利用可能であった。JPEG2000のPDFフィルタである「/JPXDecode」という文字列をgrepして、出てきた最もサイズの小さい例を使用した。また、グーグルでサンプルファイルを検索したり、Acrobat Pro / Phantom PDFを使用してテストケースを生成することも可能であった。

※訳注：シンボル情報とは、pdbファイル等のデバッグ用のシンボル名を含んだファイルに含まれている

プロのヒント1： Readerにはサンドボックスがあり、デバッグやトリアージに困ることがあるが、これは無効にすることができる - https://forums.adobe.com/thread/2110951

プロのヒント2：リバースエンジニアリング作業を支援するため、PageHeapをオンにした。これは、メモリの割り当て場所とサイズを追跡するのに役立つからである。

※訳注：PageHeapについては、https://www.keicode.com/debug/dbg-pageheap.php を参照のこと

サンプルからjp2ファイルを抽出し、PDFラッパーなしでハーネスに使用できるようにした。これは、ハーネスのテスト用入力として使用される。

最低限の動作例ができたので、```sxe ld jp2klib```を使用し JP2KLib.dll のロードイベントにブレークポイントを設定した。ブレークポイントがヒットすると、JP2KLib のすべてのエクスポートされた関数にブレークポイントを配置した。ブレークポイントコマンドは、コールスタック、最初の数個の引数、および戻り値をログに記録する。

```bm /a jp2klib!* “.echo callstack; k L5; .echo parameters:;  dc esp L8;  .echo return value: ; pt; ”```

サンプルPDFを読み込んだところ、以下のような出力が得られた。

![fig5-1](https://user-images.githubusercontent.com/77034428/163548828-b955955a-afb7-4573-b13d-1bae3731363e.png)

JP2KLibInitEx は JP2KLib をロードした後に最初に呼び出される関数である。JP2KLibInitEx は引数を 1 つだけ取ることが判明した。検証を進めると、

![fig6-1](https://user-images.githubusercontent.com/77034428/163549053-486ed962-14ce-4504-83fa-68e1d044400a.png)

サイズ0x20の構造体で、AcroRd32.dllの関数へのポインタが含まれていることが分かる。未知の関数に遭遇しても、それがターゲットコードで使用されるかどうか分からないため、急いでそれを逆引きすることはすべきではない。その代わりに、各アドレスを「nopX」（Xは数字）と呼ぶ一意の空の関数に向ける。

これで、ハーネスの骨格を書き始めるのに十分な情報が得られた。

1. コマンドライン引数から入力ファイルを取得する
2. JP2KLib.dll をロードする
3. JP2KLibInitEx へのポインタを取得し、8個の nop 関数からなる構造体で呼び出す

![fig7-1](https://user-images.githubusercontent.com/77034428/163550587-1e8e2cab-f0e2-41d7-9672-6ad84582bd6c.png)

LOAD_FUNCを便利なマクロとして使っている。。また、nop 関数を作成するための NOP(x) マクロも用意されている。

![screent](https://user-images.githubusercontent.com/77034428/163581615-b05c56a2-e1ec-4c82-b3fd-061c5456fb95.png)

コンパイルし、sample.jp2 で実行すると、上手く動作した。

```g```コマンドにより先に続ける。すると、次の関数 JP2KGetMemObjEx は引数を取らないので、これを呼び出して返り値を保存する。

次の関数 ```JP2KDecOptCreate``` も引数を取らないので、この関数を呼び出して返り値を保存する。しかし、```JP2KDecOptCreate```は内部で```nop4```と```nop7```を呼び出しているので、これらを実装する必要がある。

次の手は、"nop4" が何をするのか理解することである。nop4 の元の関数ポインタ```AcroRd32!CTJPEGDecoderRelease+0xa992```にブレークポイントを置き、実行を継続してみる。

![fig8](https://user-images.githubusercontent.com/77034428/163582197-8208b599-6459-4950-8f00-c0ef9e664a6a.png)

という結果になった。

![fig9-1](https://user-images.githubusercontent.com/77034428/163582323-8f38e9a6-4de7-4956-a053-4b240082cc92.png)

そして数ステップ後、

![fig10-1](https://user-images.githubusercontent.com/77034428/163582386-10236e06-369a-452f-9c94-b13c986d8913.png)

そこで、nop4はmallocのラッパーであることが判明した。これをハーネスに実装し、「nop4」に置き換えてみることにする。nop7について再びこの手順を繰り返したところ、memsetであることが判明した。nop5 と nop6 はそれぞれ free と memcpy であることも判明した。

次の関数JP2KDecOptInitToDefaultsは、1つの引数で呼び出されいた。これは JP2KDecOptCreate の戻り値だったので、その値を使って渡すことにする。

次の関数JP2KImageCreateは引数を取らないので、これを呼び出して戻り値を保存した。

現在、我々のハーネスは以下の様になっている。

![fig11-1](https://user-images.githubusercontent.com/77034428/163582873-6ff0a61e-a959-40ed-be84-673b4c0a54c1.png)

次の関数は、JP2KImageInitDecoderExで、5つの引数を取る。

5つの引数のうちの3つについては、JP2KImageCreate、JP2KDecOptCreate、JP2KGetMemObjExからの戻り値を対応させた。

3番目のパラメータがvtableを指していることに着目する。そして同じサイズの構造体を作成して、「nop」関数をポイントとするようにした。
第2パラメータは別の構造体を指しているが、この構造体には関数ポインタが含まれていないようである。そこで、定数値 0xbaaddaab を渡すことにした。

この時点では、コードは次のようになっている。

![fig12-1](https://user-images.githubusercontent.com/77034428/163657137-3c5aed5e-53a8-4490-991f-5f49a315b8b1.png)

ハーネスを走らせ、すぐにnop10に到達した。Adobe Readerで該当する関数にブレークポイントを設定し、以下のコールスタックに到達した。

![fig13-1](https://user-images.githubusercontent.com/77034428/163679407-79d167be-1eb0-4306-ac9c-5af40f712db6.png)

IDAでJP2KCodeStm::IsSeekableを調べてみた。

![fig14-1](https://user-images.githubusercontent.com/77034428/163679467-a8e0cf7a-b180-4bd9-85f6-8b073bac1502.png)

WinDbgを見ると、オフセット0x24のJP2KCodeStmにvtableが、オフセット0x18に0xbaaddaabが格納されていることが確認できる。JP2KCodeStm::IsSeekableは0xbaaddaabを最初の引数としてvtableの関数を呼び出しており、vtable関数#7に対する薄いラッパーになっていることがわかる。

一般に、すべてのパーサーは多少の違いはあるものの、通常はよく知られたファイル・インタフェース（FILE / ifstreamなど）の入力ストリームを消費することが多いようだ。しかし、多くの場合、入力ストリーム（ネットワーク、ファイル、メモリ）を抽象化したある種の独自の型が使用さ れることが多いようです。そのため、JP2KCodeStmがどのように使われているかを見たとき、我々は自分が見ているのが何であるかを把握することが できた。

話を戻すと、0xbaaddaabはストリームオブジェクトで、vtable関数はこのストリームオブジェクトを操作している。

IDAに移動して、他のJP2KCodeStm::XXXの関数を調べてみる。

![fig15-1](https://user-images.githubusercontent.com/77034428/163679642-6a94a6f3-1122-4f0f-a317-433e34307c47.png)

どれもよく似ているため、独自にファイルオブジェクトを作成し、必要なメソッドをすべて実装した。その結果、次のようなコードになった。

![fig16-1](https://user-images.githubusercontent.com/77034428/163692974-6aebaa51-df98-48fa-8b5d-9995259fd787.png)

JP2KImageInitDecoderExからの戻り値を確認し、エラーの場合は回避するようにした。我々の場合、JP2KImageInitDecoderEx は成功すると 0 を返す。ストリーム関数を正しく実装するのに何度か試行錯誤を重ね、ようやく目的の戻り値を得ることが出来た。

次の関数JP2KImageDataCreateは引数を取らず、その戻り値は次の関数JP2KImageGetMaxResに渡される。これらを両方呼び出して、次に進むことにした。

JP2KImageDecodeTileInterleaved関数は7つの引数を取り、そのうち3つはJP2KImageCreate, JP2KImageGetMaxRes, JP2KImageDataCreateからの戻り値である。

IDAでAcroRd32の内部をxrefして調べたところ、2番目と6番目のパラメータはNULLであることが判明した。

残るは第4,5引数のみである。これは、色深度(8/16)に関係すると判断し、色深度一定でファジングすることにした。

最終的にこうなる。

![fig17-1](https://user-images.githubusercontent.com/77034428/163693228-ab03b895-e4b8-40c9-a9f7-9e6d78845c57.png)

そして最後に、JP2KImageDataDestroy、JP2KImageDestroy、JP2KDecOptDestroyという関数を呼び、作成したオブジェクトを解放し、メモリリークを防いでいる。これは、fuzz_iterationsが高いときにWinAFLにとって重要なことである。

完了である。ハーネスが完成した。

最後の微調整として、初期化コード（JP2KLibをロードして関数を見つける）をパースコードから分離させた。これにより、fuzzingの反復処理ごとに初期化する必要がなくなり、パフォーマンスが向上することが期待できる。この新しい関数を "fuzzme "と呼ぶことにする。バイナリから関連するオフセットを探すより簡単なので、"fuzzme" もエクスポートする（exe ファイル内に関数をエクスポート可能）予定です。

補足： WinAFLでハーネスを試験した際、WinAFLが重複したマジックを含むファイルを生成することが判明した。少し調べてみると、Adobeがlibcで定義されている定数と異なるSEEK定数を使用しており、SEEK_SETとSEEK_CURを混在させていることが判明した。

※訳注：「マジック」が何を指すかは不明

## ファジングの方法論
1. ハーネスに関する基本的なテスト
   1. 安定性(Stability)
   2. パス(Paths)
   3. タイムアウト(Timeouts)
2. ファジングのセットアップ
3. 初期コーパス(Initial corpus)
4. 初期ラインカバレッジ(Initial line coverage)
5. ファジングループ
   1. ファズ(Fuzz)
   2. カバレッジ(coverage)/クラッシュ(crashes)の確認
   3. Cmin & Repeat
6. トリアージ

### ハーネスに関する基本的なテスト
大規模なファジングセッションを開始する前に、いくつかの妥当性テストを行い、サーバーを単に加熱しているだけではないことを確認すべきである。最初に確認するのは、ファザーがハーネスを使って新しいパスに到達しているかどうか、つまりパスの総数が着実に増えているかどうかである。

パス数がゼロまたはほぼゼロの場合、いくつか確認する必要がある。

- 対象関数がコンパイラによってインライン化されているため、WinAFLが対象関数への入力をミスし、WinAFLがプログラムアボートで終了している
- -引数の数（-nargs）が正しくない場合、または呼び出し規則がデフォルトでない
- タイムアウト (-Tが)小さ過ぎるため、ファザーがハーネスをすぐに停止してしまうことがある。解決策としては、タイムアウトを長くすることが挙げられる

数分間ファザーを動作させた後、安定性を確認する。安定性（stability）が低い場合（80％以下）には、デバッグを試みる。ハーネスの安定性は、ファザーの精度や性能に影響するため、重要な項目である。

#### よくある落とし穴

- ランダムな要素がないか確認する。例えば、ハッシュテーブルの実装の中には、衝突を防ぐために乱数値を使うものがあるが、これはカバレッジの精度にとって非常に悪いものであり、乱数値シードを定数値にパッチする必要がある
- ソフトウェアが特定のグローバルオブジェクトのキャッシュを持っていることがある。この影響を軽減するために、通常は目的関数を呼び出す前にnopを実行する
- Windows 10の64ビットマシン上の32ビットターゲットの場合、スタックアライメントが必ずしも8バイト以内とは限らない。つまり、memcpyや他のAVX最適化されたコードが異なる動作をすることがあり、それがカバレッジに影響を与えることがある。1つの解決策は、スタックをアライメントするコードをハーネスに追加することである

上記が全て失敗した場合は、DynamoRIOを使用してハーネスの命令トレースを行い、出力の差分を取得する。

### ファジングのセットアップ
我々のセットアップ内容は、8～16コア、32GBのRAMを搭載したVMで、Windows 10 x64が動作している。

我々はImDiskツールキットを使用して、RAMディスクドライブ上でファジングを行っている。高速なターゲットでは、ディスクへのテストケースの書き込みがパフォーマンス上の制約になることを発見した。

Windows Defenderはパフォーマンスを低下させるため、またWinAFLで生成されたテストケースの一部がWindows Defenderによって既知のエクスプロイト（「Exploit:Win32/CVE-2010-2889」）として発見されたため、無効とした。

![fig18-1](https://user-images.githubusercontent.com/77034428/163694347-246e82b2-6b9f-4424-93e4-5b2cb1eb3495.png)

Windows Updateはファジングの妨げになるため、これを無効にした（マシンを再起動し、ファジングされたDLLを置き換える）。

ハーネスプロセスのページヒープを有効にしている。これは、他の方法では検出できないようなバグを検出できることが実証されているからである。

カバレッジのタイプはデフォルトのベーシックブロックではなく、エッジを使用しているが、これはベーシックブロックモードより遅いという事実にもかかわらず、バグを見つけるのに適していることが証明さ れているためであるる。

以下はadobe_jp2kハーネスを実行するためのコマンドの例である。

```
afl-fuzz.exe -i R:\jp2k\in -o R:\jp2k\out -t 20000+ -D c:\DynamoRIO-Windows-7.0.0-RC1\bin32 -S Slav02 — -fuzz_iterations 10000 -coverage_module JP2KLib.dll -target_module adobe_jp2k.exe -target_method fuzzme -nargs 1 -covtype edge — adobe_jp2k.exe @@
```
