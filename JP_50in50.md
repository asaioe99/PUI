# 50CVEを50日間で　-Adobe Readerをファジング-

2018年12月12日（木）

Research By: ヨアヴ・アロン、ネタネル・ベンシモン

## はじめに

2017年は、脆弱性をめぐる状況の転換点であった。この年に報告された新たな脆弱性の数は約14,000件で、前年の2倍以上である（下表参照）。この理由として考えられるのは、「ファザー」とも呼ばれる自動脆弱性発見ツールの普及が進んだことである。

![fig1-1](https://user-images.githubusercontent.com/77034428/163527737-60d6a7a9-b2be-4fac-a75e-72adcd637122.png)

ファザーの存在自体は、20年以上前からあるもので、決して新しいものではない。しかし、ファザーが成長したことは事実である。より高性能になり、より身近になり、全体的に成熟してきたのである。しかし、ファザーを使うことは「ダークアート」と呼ばれ、多くの研究者はファザーを使うのが面倒だと考え、手を出さないのが現状である。

以上のことを踏まえれば、我々は当然問うべきである。「ファザーを使ってより多くの脆弱性を発見する研究者が増えている。しかし、すべての研究者がファザーを使い、すべての脆弱性を見つけているのだろうか？　「FUZZ」と書かれた大きなボタンを押す者を待っている、収穫を待つ実り豊かな果実がどれだけあるのだろうか？」

それを確かめるために、私たちは思いつく限りの最もありふれた実験を組み立てた。最も一般的なWindowsファジングフレームワークの1つであるWinAFLを使用し、世界で最も人気のあるソフトウェア製品の1つであるAdobe Readerをターゲットにした。コードのリバースエンジニアリング、脆弱性のあるライブラリの探索、ハーネスの作成、そして最後にファザーの実行まで、すべての作業に50日という期間を設定した。

その結果に私たちは驚かされた。この50日間で、Adobe Readerに50以上の新しい脆弱性を発見することができたのである。平均すると1日に1件の脆弱性が発見されたことになり、この種の調査としてはかなり異例なペースである。

本論文では、この研究の全貌を明らかにする。検索範囲を拡大するために用いた新しい方法論、WinAFLに施した改良、そして最終的に得られた洞察について紹介する。

## WinAFLとはなにであるか？

AFLはカバレッジガイド付き遺伝的ファザーであり、強固な実装と巧妙な発見的手法により、実際のソフトウェアのバグの発見に成功していることが良く実証されている。

WinAFLは、Ivan Fratric (Google Project Zero)によって作成・維持されているWindows用のAFLのフォークである。Windows版では、クローズドソースのバイナリを標的にできるように、異なる方式の計装を使用している。

AFLの仕組みについて詳しく書かれている[AFLの技術文書](https://github.com/google/AFL/blob/master/docs/technical_details.txt)を読むことを推奨する。それにより、このツールの欠点を把握し、不具合が生じた際のデバッグに役立つはずだ。

また、WinAFLが特に圧縮されたバイナリ形式（画像/ビデオ/アーカイブ）のファイルフォーマットのバグを見つけることに対し、非常に効果的であることが知られている。

## Acrobat Reader DCを攻撃する
最も簡単なのは、メインの実行ファイルであるAcroRd32.exeから始めることである。これは、約30MBの大きさのAcroRd32.dllの（比較的）薄いラッパーである。AcroRd32.dllには多くのコードがあり、その中にはPDFオブジェクトのパーサーも含まれているが、多くはGUIに関連するコードである（通常バグを探したい部分ではない）。

WinAFLはバイナリ形式の方が得意であるため、特定のパーサーを攻略することに注力した。課題は、パーサーの場所を特定し、そのためのハーネスを書くことである。ハーネスとは一体何なのかについては、後ほど説明する。

我々は、Acrobat Reader DC プロセス全体をロードすることなくロードできる、最小限の依存関係を持つバイナリ形式のパーサーを見つけたい。そこでAcrobatのフォルダにあるDLLを探索したところ、JP2KLib.dllがすべてのカテゴリーに該当することが判明した。

![fig2-1](https://user-images.githubusercontent.com/77034428/163533147-6b88b2ab-06e9-4bdf-b0d9-45a6a905a7ba.png)

JP2KLib.dll は、複雑なバイナリ形式である JPEG2000 形式のパーサーで (753 KB)、シンボル名が説明的な関数がエクスポートされていることが分かる。

![fig3](https://user-images.githubusercontent.com/77034428/163536452-0623c9d3-843e-4487-b81e-11f74efccda8.jpg)

調査は以下のバージョンで実施

Acrobat Reader DC 2018.011.20038 およびそれ以前

JP2KLib.dll バージョン 1.2.2.39492

※訳注：dllエクスポート関数のシンボル名は必ずしも残っているわけではない。また確認する際は、Dependency Walkerのリメイクである[Dependencies](https://github.com/lucasg/Dependencies)を使用することを推奨する

## 目的関数とは

目的関数とは、WinAFLがファジングプロセスのエントリポイントとして使用する関数を表す用語である。この関数は、fuzz_iterationsの回数だけループで呼び出され、そのたびにディスク上の入力ファイルを変異させる。目的関数は必ず、


- 入力ファイルを開き、ファイルを読み、入力をパースし、ファイルを閉じる
- C++の例外を投げたり、TerminateProcessを呼び出したりすることなく、正常に終了する

という条件を満たす必要がある。

しかしながら、この条件を満たす関数が存在することは、かなり珍しいことである。特に、複雑なソフトウェアをターゲットにする場合、通常はハーネスを書く必要がある。

## ハーネスとは何か

ハーネスとは、ファジングしたい機能を起動するための最小限のプログラムである。ハーネスには、目的関数として使用する関数が含まれていなければならない。以下は[WinAFLリポジトリにあるgdiplus](https://github.com/googleprojectzero/winafl/blob/master/gdiplus.cpp
)のための最小限のハーネスの例である。

![fig4-1](https://user-images.githubusercontent.com/77034428/163541656-5d35ebd0-7f4b-411a-a18f-a9fd3ac47539.png)

mainの第一引数はパスである。この関数の中で Image::Image パーサを呼び出しているが、これは我々がファジングしたい対象の API になっている。また、エラー時にプロセスを終了させず、最後にすべてのリソースを解放していることに注意してほしい。

文書化されたいるAPIの場合、この作業は比較的容易である。サンプルコードをコピーしたり、文書を参照して簡単なプログラムを書いたりすることができる。しかし、それのどこに面白さがあるのだろうか。

今回は、クローズドソースのバイナリであるAdobe Readerをターゲットに選択した。この種のターゲットに対するハーネスの書き方は、次の様になる。

1. ファジングする機能を探す
2. リバースエンジニアリングする
3. リバースエンジニアリングしたAPIを呼び出すプログラムを書く
4. 完全に機能するハーネスができるまで繰り返す

以下では、JP2KLibをリバースエンジニアリングし、動作するハーネスを作成した方法について詳しく説明する。また、いくつかヒントも紹介する。ファジングの方法論にしか興味のない読者は、次のセクションを読み飛ばしても構わない。

※訳注：当然読み飛ばしてはならないはずである

## JP2KLib.dll 用のハーネスを書く

JP2KLib.dllのリバースエンジニアリングを始める前に、そのライブラリがオープンソースであるか、公開されているシンボル情報があるかどうかをチェックした。これにより大きく時間節約をすることができるが、これは読者がが思っているよりも一般的な作業である。しかしながら、我々の場合、それほど運に恵まれてはいなかった。

我々のハーネスはAdobe ReaderがJP2KLibを使用する時の動作と可能な限り同じにしたかったため、最初にしなければならなかったことは、我々がファジングしたい動作を引き起こすPDFファイルを見つけることであった。これにより、プログラムの関連部分を簡単に探し出すことができる。

我々の場合、製品のテスト用に大量のPDFのコーパスが利用可能であった。JPEG2000のPDFフィルタである「/JPXDecode」という文字列をgrepして、出てきた最もサイズの小さい例を使用した。また、グーグルでサンプルファイルを検索したり、Acrobat Pro / Phantom PDFを使用してテストケースを生成することも可能であった。

※訳注：シンボル情報とは、pdbファイル等のデバッグ用のシンボル名を含んだファイルに含まれている

プロのヒント1： Readerにはサンドボックスがあり、デバッグやトリアージに困ることがあるが、これは無効にすることができる - https://forums.adobe.com/thread/2110951

プロのヒント2：リバースエンジニアリング作業を支援するため、PageHeapをオンにした。これは、メモリの割り当て場所とサイズを追跡するのに役立つからである。

※訳注：PageHeapについては、https://www.keicode.com/debug/dbg-pageheap.php を参照のこと

サンプルからjp2ファイルを抽出し、PDFラッパーなしでハーネスに使用できるようにした。これは、ハーネスのテスト用入力として使用される。

最低限の動作例ができたので、```sxe ld jp2klib```を使用し JP2KLib.dll のロードイベントにブレークポイントを設定した。ブレークポイントがヒットすると、JP2KLib のすべてのエクスポートされた関数にブレークポイントを配置した。ブレークポイントコマンドは、コールスタック、最初の数個の引数、および戻り値をログに記録する。

```bm /a jp2klib!* “.echo callstack; k L5; .echo parameters:;  dc esp L8;  .echo return value: ; pt; ”```

サンプルPDFを読み込んだところ、以下のような出力が得られた。

![fig5-1](https://user-images.githubusercontent.com/77034428/163548828-b955955a-afb7-4573-b13d-1bae3731363e.png)

JP2KLibInitEx は JP2KLib をロードした後に最初に呼び出される関数である。JP2KLibInitEx は引数を 1 つだけ取ることが判明した。検証を進めると、

![fig6-1](https://user-images.githubusercontent.com/77034428/163549053-486ed962-14ce-4504-83fa-68e1d044400a.png)

サイズ0x20の構造体で、AcroRd32.dllの関数へのポインタが含まれていることが分かる。未知の関数に遭遇しても、それがターゲットコードで使用されるかどうか分からないため、急いでそれを逆引きすることはすべきではない。その代わりに、各アドレスを「nopX」（Xは数字）と呼ぶ一意の空の関数に向ける。

これで、ハーネスの骨格を書き始めるのに十分な情報が得られた。

1. コマンドライン引数から入力ファイルを取得する
2. JP2KLib.dll をロードする
3. JP2KLibInitEx へのポインタを取得し、8個の nop 関数からなる構造体で呼び出す

![fig7-1](https://user-images.githubusercontent.com/77034428/163550587-1e8e2cab-f0e2-41d7-9672-6ad84582bd6c.png)



