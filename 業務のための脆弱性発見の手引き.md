# 業務のための脆弱性発見の手引き
本解説は、対象の情報システムに対しその脆弱性を発見することが業務である人のために、Fuzzingについて取り急ぎ最低限の知識を身に着けるためのものである。その中でも特に、管理者と実務担当者を対象として本解説を作成しているが、実務担当者は本解説の全てを読み、実際に手順を体験すべきである。一方で管理者は本解説を読むだけで良いが、実務担当者が手順を体験する様子を十分に観察すべきである。観察することで、実務担当者自身が気付くことのできない重要なことを発見するかも知れないからだ。

この解説だけでは完結しない知識もあるので、その部分については参考文献を載せているので参照して頂きたい。また、管理者については実際にFuzzingを実施する訳ではないので、主に必要な環境や整えておくべき人材、更に機材や人材を評価する観点について良く理解すべきである。しかしながら、管理者が適切に原理や一般論としてのFuzzingを理解していないと、本来得られるはずであるパフォーマンスが発揮されないばかりか、実務担当者の不平不満や、反対に怠慢を許す恐れがある。そのため、余力があれば実務担当者と同様に、実際にFuzzingを実施する体験をして欲しい。

本解説では、実務担当者の業務手順習得のために、実在するアプリケーション（JWCAD：CAD用のフリーソフト）に対してFuzzingを行う。そして、そのために必要な環境構築についても一通り解説する。そのため、ある程度の関連知識の不足があったとしても、管理者は実務担当者と一緒にFuzzingを体験することができる。一度でも良いから実際の業務の流れを体験することで、様々な良い効果があることは間違いない。是非検討すべきである。

## それで何ができるのか
Fuzzingにより半自動的に対象のアプリケーションから脆弱性を発見することで、その脆弱性を解析し、可能であればRCEの様な攻撃に発展させることが可能である。これにより、必要に応じて情報システムを改修し、より堅牢なシステムへと発展させることができる。これは、一部の企業では既にアプリケーションやシステムの開発における必須工程となっている。これにより、自社の開発・運用を行う情報システムの信頼性を高め、悪意のある人間からの攻撃を未然に防ぐことができる。また攻撃者にとっては、攻撃対象の情報システムに使用されているアプリケーションの脆弱性を半自動的に発見することで、効率的に攻撃手段を蓄積することが可能である。

いずれの目的によっても、より効率性の高いFuzzingを実行することが重要であることが分かる。十分な経験と高性能な計算機を用意できた組織は、いずれの目的にせよ高いパフォーマンスを発揮できる可能性が高い。

# Fuzzing入門
ここからは、Fuzzingを正しく実施し、適切な効果を上げるために必要な関連する技術分野に関して説明を行う。

## Fuzzingの原理
Fuzzingを行う目的は、対象のアプリケーションから脆弱性を自動的に検出することである。ここで言う脆弱性とは、不正なメモリアクセスや無限ループ（ hang）を誘起するような入力（以下「不正な入力」という）として発見される。

つまり、今回体験するJWCADに対するFuzzingの場合、JWCADに対して様々なファイルを読み込ませ、その中からJWCADに対して不正なメモリアクセスや無限ループを引き起こすようなファイルを発見するのである。

## 不正な入力を発見する方法
恐らく疑問を持った方も多いだろうが、不正な入力を発見する方法は一見して明らかではない。例えば、総当たりで全てのbitパターンを調査する方法が思いつく。この方法であれば、原理的には全ての不正な入力を発見できそうである。しかしながら、現実的な時間ではこの計算を終えることができないので、より効率的な方法を考える必要がある。

### 正規の入力を壊す
最初に思いつく方法は、元々正常な読み込みのできるファイルや入力を少しだけ変更する方法である。これには一応の理屈があって、

- いきなりランダムな入力を使うと、parserに弾かれる
- bit反転や延長で、入力値を気軽に変化させられる

というものである。

実際、これは悪くない戦略である。入力データ内のある部分が、その入力データのサイズを表していた場合、その部分の一部のbitを反転させると、本来のファイルサイズとは異なる値になってしまう。その場合、対象のアプリケーションに対策がされていなければ、本来のデータサイズを超えた領域までアクセスしてデータを読み取ろうとしてしまうことが一応は予想される。

その結果、不正なメモリアクセスを行ってしまうかも知れない。また、入力された値に応じて、読み込みではなく書き込みを行うのであれば、特定のメモリ領域に対して意図した値を書き込めるかも知れない。そうすれば、何らかの悪意のあるコードを実行できるかも知れないのである。

上手く本来の入力の一部だけを壊すことにより、parserの目を誤魔化しつつも不正な操作を行える可能性がある。そして実際に、この戦略に似たものがWinAFLによるFuzzingで```bit flips```や```byte flips```として採用されている。

### メモリに明かりを灯す
他にも戦略がある。例えば、メモリ（厳密にはtextセクション）のどの部分を実行しているか、その実行している箇所が光ったとしよう。そして更に、実行した部分は一度点灯したらそのまま光り続けたとする。

その様な場合、プログラムを実行した場合、entryポイントから順に明かりが灯り、そして条件分岐によって実行箇所が飛んだ場合は、その先から同じように明かりが灯ることになる。最終的にプログラムが終了するまでに実行された部分は全て明かりが灯るが、例えば条件分岐により飛ばなかった部分は暗いままである。

これが何を意味しているかはそれほど明らかではない。しかし、もし本来コードとして実行されることを想定しない領域（データ領域）に明かりが灯ったら面白いはずである。つまり、入力したデータの何らかの作用により、本来想定されていない動作が生じた可能性が高い。

ここで、何らかの方法によってメモリに明かりを灯すことができれば、メモリの明るい部分の範囲（covarage：カバレッジ）の広さにより、脆弱性を生じさせ易さを計測することができそうである。

### 実際の方法
実際にはメモリに明かりを灯すことは困難であるので、より簡単な方法を採用している。例えば、我々が観測したいのは実行されたことのあるメモリの範囲であり、それを調べるだけであれば、条件分岐の部分だけを観測しておけばよい。つまり、トンネルの入り口と出口だけを監視していれば、トンネルの内部まで車を追わなくても良いのである。

そこで、実際の方法としては、このトンネルの入り口に相当する部分に対して、そこを通過したことを観測する特殊なコードを仕組んでプログラムを実行している。この特殊なコードというのは単なるジャンプ命令であり、トンネルの入り口で一度別の部分に車を誘導し、そこで車両が通過したことを記録した上で、再度トンネルの入り口に戻しているだけである。

これは例え話であるが、実際の場面ではバイナリ計装と呼ばれる考え方である。そして、ソースコードを書き換えて計装（instrumentation：インストラメンテイション）する場合と、実行中のプログラムに対して計装する方法があり、順に静的/動的バイナリ計装と呼ぶ。

そして、計装によりカバレッジを大きくするように入力を変化させることで、不正な入力を発見することができる。本解説では、カバレッジ拡大を目指す上で、どの様に入力を変化させるかについては説明しないが、念のために参考文献を示す。

参考：探しておきます

### 必要な時間
これまでの説明で、不正な入力を発見するための考え方について説明した。問題は、どのくらいの時間をかけてFuzzingを行えば脆弱性を検出できるかである。結論から言えば、必要な時間は予測不可能である。解析対象のアプリケーションが一切脆弱性の存在しない完璧なものであれば、当然無限に時間をかけても発見することはできない。反対に脆弱性の塊の様なアプリケーションであれば、Fuzzing開始と同時に堰を切ったかの様に脆弱性が発見される。そしてこれらは、解析に利用するコンピュータの性能に大きく依存する。

そのため、どれくらい時間が必要かを見積もることよりも、どれくらいの時間で脆弱性が発見されたかで判断すべきである。つまり、高性能なコンピュータによる１ヶ月間ものFuzzingにより、一つも脆弱性が発見されなかったのであれば、それは相当に堅牢なアプリケーションであり、これを攻撃する者達も少なくともこれと同じ以上の解析費用を必要とする。

また、攻撃者としての視点に立てば、対象のアプリケーションを自由に選ぶことのできない状況であれば、如何なるコストを支払ってでもFuzzingを継続し、脆弱性を何としてでも発見しなければならない。結果的に発見できない可能性もある訳で、もし時間的制約があるのであれば、一定の基準を定め、その時間内に成果を出せなければ打ち切る必要がある。

### 必要なコンピュータの性能
今までの話から単純に論じれば、コンピュータの性能が倍になれば、同じ時間で発見できる脆弱性の数も倍になりそうに思える。これはある程度は事実であるが、注意点もある。

ここで押さえておきたいことは、発見した不正な入力の数を単純に評価してはならないということである。重要なのは種類である。つまり、プログラム中の同じ脆弱性に対して作用する不正な入力を作るだけなら、実はいくらでも数を増やすことができてしまうのであり、本来評価すべきなのはプログラム中に存在する脆弱性をいくつ発見したかである。この事実は必ず押さえておく必要がある。そして発見可能な脆弱性の種類は、使用するFuzzerや解析者の能力にも依存している。そのため、厳密な議論は困難である。

さて、以上を理解した上で、それでもコンピュータの性能が重要であることを強調しよう。そして、以下の様な点に注意して導入するコンピュータを決定すべきである。

- CPUのコア数が多い
- メモリのサイズが大きい
- 高速に読み書きできる不揮発性記憶媒体（SSD）を使用している
- 堅牢で信頼性が高い
- 突然の停電等にも対応できる電源を有している

以上の条件について、参考として現時点(2022/3/12)で快適なFuzzingを実施する上で標準的な環境を以下に示す。

#### CPU
最も重要な要素であるため、優先してリソースを割くべきである。以下は、優れた性能であると考えられる具体的な製品の紹介である。

- Intel Core i9-12900K

  16コア24スレッドであるため、WinAFLであれば最大24プロセスの並列処理が可能である。また、シングルコア当たりの性能が高いため、優れたパフォーマンスを発揮できる。また、Intel PTという機能に対応しているため、特定の条件のみではあるが、他社同等製品のCPUよりも１桁以上高速にFuzzingを実施可能な場合がある。

- AMD Ryzen Threadripper PRO 3995WX

  64コア128スレッドであり、現時点では最速のFuzzingが実施可能であると考えられる。

#### メモリ
十分な容量が必要であるが、特に重視すべき点は読み書きの速度である。現時点ではDDR5 SDRAMという規格が最速であり、この規格のメモリを使用することが望ましい。容量は、多ければ多いほど良く、少なくとも32GByteは必要である。

#### ハードディスク
容量よりも高速な読み書き性能が重視される。特に、Fuzzing対象のアプリケーションがハードディスクにアクセスするような動作をする場合、別に特別な対策を採用しない場合、この読み書き速度に律速される。そのため、現時点で最速の性能であるPCIe 4.0規格のSSDを使用することが推奨される。

#### 電源等
突発的な停電により機材が停止すると、それまでに実施していたFuzzingの結果が失われてしまう可能性がある。そのため、複数の冗長性による堅牢な電源構成を構築すべきである。そのため、端末専用のUPSは必須であり、併せて施設そのものの電源についても、商用とは別に発動発電機とUPSを導入することが理想である。

#### その他
以下は個別の要考慮事項である。重要なものも含まれているので、必ず目を通すべきである。

- アンチウイルスソフトについて

  アンチウイルスソフトは、Fuzzingと同じ動的バイナリ計装という技術を用いていることもあるため、同時に用いることは推奨できない。そのため、Fuzzing端末についてはOS標準に機能を除き、アンチウイルス製品を導入は控えるべきであるか、任意に機能を停止可能な仕様とすべきである。

- 各種解析ツール

  Fuzzingを実施する際には、先だって対象のアプリケーションを解析する必要がある。そのため、WinDBGやGhidra等のツールが必要になる。ここで重要なのは、これらのツールは必ずしも商用の製品は必要ではなく、全てOSSのもので十分に要件を満たすが、一方で、インターネット接続環境が制約なく整備されていない場合、これらのOSSを満足に利用できない。そのため、以降で示す環境構築時の手順を熟読し、これらの環境を不便なく構築できるようにしなければならない。

- 端末の数について

  最小構成であっても、Fuzzing用の端末と解析用の端末で各１台は必要である。解析用の端末は、Fuzzing用とは異なり最高性能を目指す必要はない。また、Fuzzing用の端末については、複数の端末を連携・分散させることもできるため、より高速なFuzzingが求められる場合は複数の端末を導入し、ネットワークを構成することも考えるべきだる。残念ながらこの様な運用方法に関する実用的な経験や技術文献がないため、本解説では触れることができない。

### 必要な人材（管理者は要熟読）
組織としてFuzzingを行う際に注意したいことは、必要な機材に関する特性だけではなく、人材についても多くある。以下は考慮すべき事項である。

- プログラミングの経験がある（具体的な成果物を示すことができる）
- 脆弱性の原理について知っている（専門用語を使わないで説明できる）
- 自主的に学習を進められる性格である（技術進歩が早いため、常に勉強が必要）
- 知識・技術を周囲に普及できる（効率化には情報共有が必須である）
- コンピュータ本体に関する知識と技術がある（環境構築や維持運用に必要）
- 英語や中国語を始めとした外国語の読解力（技術情報の大半は外国語）

他の技術とも共通する要素は少なくないが、Fuzzingに関する技術情報は広く出回ってはいないため、体系的な入門書や解説書は存在していない。そのため、自発的に情報を収集し、新たな技術を学習し、そして発見した技術や情報を組織に還元する能力が必要である。そして、ここで示したような能力を発揮した人間を評価すべきである。

## 不正な入力を発見したら
今までに説明した様々な方法により、メモリアクセス違反や無限ループを引き起こすような入力を発見した場合、次に行うのは、入力したデータのどの部分がプログラムのどの部分に作用して不正な動作を引き起こしたかを解析することである。

この解析を行うのに必要な技術は以下の通りである。

- C/C++言語の実用的な技術
- 静的解析の技術
- 動的解析の技術
- アセンブリの実用的な技術
- アーキテクチャに関する実用的な知識
- OSに関する実用的な知識


これらの知識及び技術を用いることで、発見した不正な入力を元に、アプリケーションのどの部分に脆弱性が存在し、そしてその仕組みについて明らかにすることになる。

その過程で、脆弱性の緩和策（修正方法や軽減方法）を考えることも必要になるだろうし、反対にその脆弱性を利用した攻撃方法を考える必要もあるだろう。

### 脆弱性のメカニズム
大まかにではあるが、脆弱性の原因となるいくつかの典型的な仕組みについて説明する。

#### ハンドル
Windowsで動作するアプリケーションは、通常多くのハンドルを操作しながら動作している。例えば、ファイルハンドルやデバイスハンドル、キーハンドル等があるが、これらは一連の固有なIDであり、各値はOSにより与えられている。対象となるファイルのアドレスを直接扱うのではなく、このIDを介して操作することになる。

後に目的関数の決定において説明する、```CreateFile```関数を例に説明する。これは、

```c
hFile = CreateFile(ファイル名, アクセス方法, その他複数の引数);
```
となっており、戻り値として16進数4桁のIDが与えられる。そしてこのIDはカーネルモードメモリに保存されているアドレスと一対一に対応している。もしそうでなければ、直接対象のアドレスにアクセスすることになり、もしもその値に何らかの誤りがあった場合に危険である。

そしてこの場合、

```c
WriteFile(hFIle, データのアドレス, 書き込む長さ, その他複数の引数);
```

という形式で、ファイルハンドルを経由して間接的にファイルに対して書き込みを行う。

当然、必要な処理が終わればハンドルは開放しなければならない。そうでなければアプリケーション終了後であっても、カーネルメモリ上に確保されたハンドルがそのまま残ってしまう。これをハンドルリークと呼ぶが、これがカーネルメモリを圧迫し、最悪の場合はシステムがクラッシュしてしまう。

#### スタック
ハンドルの場合は、カーネルメモリを食い潰すという意味で危険な脆弱性であった。他にも同様の仕組みにより発生する脆弱性がある。頻繁に見かけるものとしては、スタック領域を使いつくしヒープ領域にまで達する脆弱性である。これは、以下の仕組みにより成る。

```c
int func(int a, int b) {
	return func(a,b);
}

int main() {
	func(1,2);
	return 0;
}
```

この様なプログラムを考えると分かりやすいが、この場合、再帰的に関数を呼び出すことにより、幾重にもスタックに引数とリターンアドレスを積み上げていくことになる。そうすると、最終的にプログラムはクラッシュする。この様な場合、クラッシュした地点からスタックのバックトレースを確認すると、とてつもない数のフレーム数になっている。あまり見慣れていないと分からないかも知れないが、スタックのフレーム数は通常多くても100フレームを超えることは稀である。

#### アクセス違反
上記の説明に共通していたことは、いずれの種類にせよ、最終的に問題となるのはあるアドレスにアクセスしてしまい、アプリケーションやシステムが動作するのに使用しているメモリの一部を破壊してしまったことである。これを一言でまとめれば、本来アクセスしてはならないメモリの領域に、書き込みや読み込み、更に実行をしてしまったということである。そしてこれは攻撃に応用されることもある。

参考：
https://www.ipa.go.jp/security/awareness/vendor/programmingv2/cc01.html

### 脆弱性の攻撃方法
これまでの説明でもあった通り、脆弱性には本来意図していないアドレスにアクセスし、何らかのデータを書き込むという側面がある。これが無秩序に行われた場合、アプリケーションやシステムはクラッシュすることがあるが、もしもこれを制御可能であり、特定のアドレスに対して特定の値を書き込むことができたのならば、攻撃に転用できる。

以下加筆待ち。

### 脆弱性の修正方法
後で追加。```_s```の関数について簡単に紹介したい。あとは開発環境をそもそも変えるとか？

# WinAFL入門
前置きが長くなったが、これからは実際にFuzzingを実施し、脆弱性を発見する。本解説では脆弱性の修正方法や攻撃方法については取り扱わない。したがって、本解説と同様の方法で別のアプリケーションに大してFuzzingを行い、何らかの脆弱性を発見した場合は、そのアプリケーションの開発者と直接連絡ができる場合は相談することを勧める。

## 必要なものリスト
- WinAFL

   https://github.com/googleprojectzero/winafl
   
   Fuzzingの対象によっては、自分でソースコードを修正して都度ビルドする必要がある。

- DynamoRIO-Windows-8.0.18460

   https://github.com/DynamoRIO/dynamorio/releases/tag/cronbuild-8.0.18460

   DynamoRioはビルドせずにそのままbin32/64を使用

- Visual Studio Community 2017 (version 15.9)

   https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads

   WinAFLのビルドに使用

- cmake-3.23.0-rc3-windows-x86_64

   https://cmake.org/download/
   
   WinAFLのビルドに使用

- git for windows version 2.35.1.2

  https://gitforwindows.org/

  WinAFLのダウンロードに使用

- JWCAD　(ver8.24a)

   https://www.jwcad.net/download.htm

   今回の解析対象

- Ghidra 10.1.2

   https://github.com/NationalSecurityAgency/ghidra/releases/tag/Ghidra_10.1.2_build

   JWCADを解析し、```target_offset```を選定するために使用

- WinDbg Preview

   https://www.microsoft.com/ja-jp/p/windbg/9pgjgd53tn86?SilentAuth=1&wa=wsignin1.0&rtc=1&activetab=pivot:overviewtab

   JWCADを解析し、```target_offset```を選定するために使用

## DynamoRioの準備
DynamoRioは、動的バイナリ計装に関する機能を提供するライブラリである。動的バイナリ計装はGrey Box Fuzzingでは必須の技術である。ここまでの解説により、理解に必要な知識が一通り揃ったので、Fuzzingの種類について触れた上で、DynamoRioの導入方法について説明する。

### White Box Fuzzing
White Box Fuzzingは、解析対象のアプリケーションのソースコードを自由に利用可能な場合（ソースコードがない場合でも一応は可能だが、問題が多い。詳細は後述）に用いる方法である。WinAFLのフォーク元であるAFL（Linuxアプリケーションに対してWhite Box Fuzzingを行うツール）では、専用のコンパイラにより、解析対象のアプリケーションのソースコードをコンパイルする際に静的バイナリ解析用のコードを仕込むことによりカバレッジを計測している。

### Grey Box Fuzzing
本解説で説明するWinAFLでは、DynamoRioにより動的バイナリ計装を行い、解析対象のプリケーションを動作させながら、カバレッジを測定する。実行中のアプリケーションの動作を動的に変更しながらカバレッジを計測するため、解析に要する速度は静的バイナリ計装、つまりWhite Box Fuzzingよりも低速になる。

しかしながら、解析対象のアプリケーションのソースコードが入手できる場合は限定的であり、実際の業務の上ではGrey Box Fuzzingが主体となると考えられる。そのため、本解説ではGrey Box Fuzzingのみを扱う。

また、これとは別にBlack Box Fuzzingという手法も存在する。これは、対象のアプリケーションそのもの（実行ファイル等）が入手できない場合に行うFuzzingのことを指すが、筆者にはこの方法に関する十分な経験がないため、説明はできない。

### 動的バイナリ計装と静的バイナリ計装の比較
ここで、動的バイナリ計装（DBI）と静的バイナリ計装(SBI)の特徴を比較する。

| DBI  | SBI  |
| ---- | ---- |
|-低速|+高速|
|-解析環境の共有が困難|+解析環境の共有が容易|
|+解析対象のライブラリを考慮しない|-解析対象のライブラリも計装する必要がある|
|+解析対象の動作の一部のみを解析可能|-解析対象の動作全般を解析しなければならない|

### 静的バイナリ計装についての補足
静的バイナリ計装を、解析対象のソースコードが入手できない場合に実行した場合の特徴について解説する。

この様な条件でも解析は可能で、その場合は解析対象を逆アセンブルし、バイナリレベルで計装コードを追加することになる。研究用のツールとして、PEBILやDyninstと呼ばれるものが利用可能だが、発展途中である。ここでは詳細についてはこれ以上触れないが、動的バイナリ計装との比較を下に示す。

| DBI  | SBI  |
| ---- | ---- |
|+逆アセンブルが不要|-逆アセンブルが必要でエラーが起こりやすい|
|+バイナリの書き換えが不要|-バイナリの書き換えでエラーが起こりやすい|
|+pdbファイルの様なシンボル情報が不要|-安定動作のためにはシンボルが必要|

### DynamoRioのダウンロード
今回の解説で使用するDynamoRioのバージョンは、```DynamoRIO-Windows-8.0.18460```である。ダウンロード先は以下の通りである。

URL：
https://github.com/DynamoRIO/dynamorio/releases/tag/cronbuild-8.0.18460

```DynamoRIO-Windows-8.0.18460```フォルダは、自由に名前を変更しても良い。WinAFLの実行時には、フォルダ内のbinフォルダのパスをコマンドに指定しなければならないので、なるべく短い名前にすべきである。しかしながら、WinAFLのバージョンや解析対象のアプリケーションとの相性によっては、複数のDynamoRioのバージョンを使い分ける必要があるため、使用するバージョンは明示すべきである。そのため、本解説では```DynamoRIO8.0.18460```という名称に変更する。

さて、ダウンロードが終わったらフォルダの中身を確認してほしい。以下の様になっている筈である。

- bin32

  32bit用のビルド済ファイル
- bin64

  64bit用のビルド済ファイル
- cmake
- docs
- drmemory
- dynamorio

  技術資料が含まれている
- ext
- include
- lib32
- lib64
- logs
- samples
- ACKNOWLEDGEMENTS
- Licence.txt
- README

基本的にはこのまま使用するのでビルドする必要はないが、WinAFLが上手く動作しない場合は、解決方法の一つとしてDynamoRioのFuzzing環境下でのビルドがある。そのため、以下の手順は問題が発生した場合のみ参照すれば良い。

### DynamoRioのビルド
後で追加します。

### DynamoRioの関数紹介
解析対象のアプリケーションによっては、動作中にメッセージボックスが表示される場合がある。この場合、メッセージボックスのボタンを押下するまで動作が停止する場合もあるため、Fuzzingを実行する上では解決しなければならない。

一つの方法として、VBSによりこれらの操作を自動化する方法があるそうだが、筆者は試したことがない。より洗練された方法としてはDynamoRioにより、メッセージボックスの表示を行うAPI（MessageBoxAやMessageBoxW）をフックして、別に解析者が用意したダミーの処理とすり替える方法がある。

以下は、フックによる処理のスキップの具体例である。尚、本例はJWCADのFuzzingでも用いるため、機能の具体的な実装方法はそちらでも示す。

さて、今回使用するDynamoRioの関数は２つあり、それぞれ順に説明する。

補足：
https://dynamorio.org/group__drwrap.html#ga488a6566cd760a3919bdd2f49a6d672f に解説があるのでそちらを参考にしても良いが、初めての場合は難しいと思う。

#### ```dr_get_proc_address```の詳細
```c
DR_API generic_func_t dr_get_proc_address(module_handle_t lib,
		                                  const char *    name) 	
```
この関数は、第１引数に対してdllのベースアドレスを指定し、第２引数に関数名を指定することで、戻り値として当該関数のエントリーポイント（先頭のアドレス）を取得できる。

#### ```drwrap_replace```の詳細
```c
DR_EXPORT bool drwrap_replace(app_pc original,
		                      app_pc replacement,
		                      bool   override) 	
```
この関数は、第１引数に指定したアドレスの関数を、第２引数に指定したアドレスの関数で置き換えるものである。更に第３引数で```true```を指定した場合、先に第１引数で指定したアドレスの関数が別き換えられるように別で設定されていた際に、これに優先して置き換えることができる。```NULL```の場合はその逆である。

#### 実際の使用例
先に紹介した両関数を組み合わせた応用例について説明する。

```c
if (_stricmp(module_name, "USER32.dll") == 0) {
	to_wrap = (app_pc)dr_get_proc_address(info->handle, MessageBoxW");
	drwrap_replace(to_wrap, (app_pc)Messageboxw_interceptor, NULL);
}
```
この例では、```module_name```が文字列```USER32.dll```と一致した場合、ポインタ```to_wrap```に対して```dr_get_proc_address```関数により取得した```MessageBoxW```関数のアドレスを代入している。その後、```drwrap_replace```関数の第１引数に```to_wrap```を指定し、```MessageBoxW```が呼び出された際にこれをフックして、代わりに準備した```Messageboxw_interceptor```関数とすり替えている。

## Visual Studio 2017の準備
Visual Studio 2017は、WinAFLのビルドに必要である。基本的には[こちら](https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads) からVisual Studio Community 2017(version 15.9)を選択してダウンロードすれば良い。インストーラを入手したら、あとは手順に従ってインストールを完了させれば良い。

注意点としては、スタンドアロン端末にインストールする場合は別の方法が必要であり、本来の方法よりも数倍は時間も手間も掛かる。問題が発生した際の対処にも同様に時間と手間を要し、しかも場合によってはスタンドアロン環境では解決不可能な場合もあるため、業務としてFuzzingを実施する場合は、この点について特に慎重に検討をすべきである。その上で、オフライン環境下でのVisual Studio のインストール方法について説明する。

### オフライン環境下でのインストール手順
まずは、インターネットに接続している環境下で、オフラインインストールファイルを作成する。

1. [Visual Studio 2017](https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads)のインストーラをダウンロード
2. インストーラを任意の空のフォルダに配置
3. 下記のコマンドを１行ずつ実行しダウンロード完了を待つ

```
mkdir in_vs2017
vs_community__xxxxxxxx.xxxxxxx.exe --layout in_vs2017 --lang ja-JP
```
4. ダウンロード端末にフォルダを移動する
5. フォルダ内の```vs_community__xxxxxxxx.xxxxxxx.exe```を実行

後は、通常の手順と同じである。

## cmakeの準備
cmakeはWinAFLのビルドで必要なツールである。[こちら](https://cmake.org/download/)から、```cmake-3.23.0-rc3-windows-x86_64.msi```をダウンロードし、インストールを始めれば良い。オフライン環境でも動作するため、Fuzzing端末がスタンドアロンであっても問題なくインストールできる。

## git for windowsの準備
環境構築ではgitにより行うのが楽である。特に、WinAFLやDynamoRioはthird partyとして他のライブラリに依存している部分もある。そのため、それらも含めてダウンロードするにはgitの```-recursive```が便利である。そういう理由もあるため、基本的にはgitの利用を推奨するが、何らかの理由により使用できないのであれば、先述の通り、依存関係に注意して手動でダウンロードすべきである。

https://gitforwindows.org/

## WinAFLの準備
WinAFLの準備は大変である。まず前提として、Visual Studio 2017のインストールが必要なので、まだ済ませていないのであれば、先に説明した通りに実施して頂きたい。また、cmakeのインストールも忘れずに実施しなければならない。

### WinAFLのビルドの練習
本解説では、Cドライブ直下にWinAFLをインストールすると仮定して説明する。

まずは、スタートメニュー → すべてのアプリケーション → Visual Studio 2017 → x86 Native Tools Command Promptを開く。（Windowsキー押下後に、```x86```と入力すると候補に表示される）

その後、```x86 Native Tools Command Prompt```上で以下の様に実行する。

```
$ cd C:\
$ git clone --recursive https://github.com/googleprojectzero/winafl
$ cd winafl && mkdir build32 && cd build32
$ cmake -G"Visual Studio 15 2017" .. -DDynamoRIO_DIR=path_of_DynamoRIO_cmake
$ cmake --build . --config Release
```
```-DDynamoRIO_DIR=```以下にはDynamoRioのcmakeフォルダのパスを指定する。cmakeフォルダをshift + 右クリックで```パスのコピー```をクリックすれば簡単である。

もしも上記例と同様にgitが利用できない場合は、手動でWinAFLをダウンロードし、```git clone --recursive```により本来ダウンロードされるはずであった、```third_party```フォルダ内のファイルを全て手動で用意する必要がある。

手動での準備が終わったら、

```
$ cd C:\
$ cd winafl && mkdir build32 && cd build32
$ cmake -G"Visual Studio 15 2017" .. -DDynamoRIO_DIR=path_of_DynamoRIO_cmake
$ cmake --build . --config Release
```

として、当初の手順に合流すれば良い。

WinAFLのダウンロードは、[こちら](https://github.com/googleprojectzero/winafl)で、code → Download ZIP を選択すれば良い。

![winaflgit](https://user-images.githubusercontent.com/77034428/158393391-5c3dcf4b-a424-47e4-849e-0d1556e65eb4.jpg)

念のために、上記コマンドの主要な手順を順に示すと、

```
C:\winafl\build32>cmake -G"Visual Studio 15 2017" .. -DDynamoRIO_DIR=C:\DynamoRIO8.0.18460\cmake
```

![cmake1](https://user-images.githubusercontent.com/77034428/158393299-ff23c80e-4725-44e5-850c-6e039047cc69.jpg)

```
C:\winafl\build32>cmake --build . --config Release
```

![cmake2](https://user-images.githubusercontent.com/77034428/158393251-7a0f935a-6180-4ca3-beab-2f9defc1ae42.jpg)

となる。

無事にビルドが完了したら、build32フォルダ内に多数のファイル等が生成されている筈である。

今後の流れとしては、Fuzzing対象のアプリケーションに応じてWinAFLを改造し、その都度専用のFuzzerとしてビルドすることになる。そのため、今回説明したビルド手順には慣れておくべきである。


## JWCADの解析△〇
Fuzzingを開始する前に、解析対象のアプリケーションを調査する必要がある。基本的な考え方としては、どの様に対象のアプリケーションに入力を与えることができるか、である。つまり、アプリケーションに対してGUIの操作を要する方法でしか入力を与えられない場合は、何らかの方法でこの操作を自動化しなければならない。これは簡単ではなく、相応の経験と技術が必要で、Windowsアプリケーションの開発経験があれば理想である。

さて、今回の場合、JWCADは以下の様なコマンドによって読み込むファイルを指定して起動することができる。そのため、JWCAD本体を修正する必要は一切ないが、いくつかの問題からWinAFLに手を加える必要がある。

```
Jw_win.exe file.jww
```
ここで説明するのは、上記コマンドの通りにJWCADを操作した際に、何らかの人の手による操作が不要であるかを確認し、もしも何らかの問題があれば、どの様にそれを除去するかである。

### 拡張子
JWCADで対応している拡張子は、```JWC```、```JWW```、```DXF```、```SFC```、```P21```の５種類である。そこで、正規のjwwファイルの拡張子を別の非対応の拡張子jpgに変更して読み込ませてみる。すると、```JW_CADでは読み込めないファイルです```と表示された。

これにより１つの事実が判明した。つまり、JWCADは最初に拡張子でファイルの種類を判定しており、仮に正規のファイルであったとしても、拡張子が上記のいずれかでなければならないということであることが分かる。

更に実験してみると、jwwファイルの拡張子をp21に変更しても問題なく開くことができた。つまり、上記５種類の拡張子であれば取り敢えずファイルの読み込み自体は行われ、その過程で何らかの方法によりそれぞれのフォーマットを判定して読み込んでいる。

試しに、全く無関係なbmpファイルの拡張子をjwwに変更して読み込ませてみると、```このファイル形式には対応していません```と表示された。これにより、上記の５種類のいずれかのファイルであると判定されなかった場合は、それ以上読み込みを行わないことが分かる。

これらの事実から、WinAFLの生成する入力ファイルにはいずれかの拡張子を付けなければならないことが分かる。実は、WinAFLはFuzzingの過程で生成する入力ファイルには拡張子を省く仕様になっている。そこで、この部分について後ほど修正が必要である。

### メッセージボックス
実は既に拡張子とファイル読み込みの部分で判明しているが、入力されたファイルが正規のフォーマットではないと判断されると、メッセージボックスが表示され、動作が中断してしまう。その都度動作が停止してしまうと、Fuzzingを適切に実行できない。

そこで、MessageBox関数の呼び出しをフックすることで、別に用意した関数とすり替え、動作を継続されられるように、WinAFLを後ほど改造する。詳細についてはDynamoRioの説明である程度しているので、必要に応じて遡って参考にしてもらいたい。

## WinAFLの改造
JWCADの解析結果により、以下の２点の修正が必要であることが分かった。

- ファイル拡張子の追加
- メッセージボックスのすり替え

そこで、これらの修正方法を説明する。

### afl-fuzz.cの修正
修正箇所は```afl-fuzz.c```内の計３箇所である。ソースコード内を```.cur_input```で検索すれば良い。この```.cur_input```はWinAFLがFuzzing中に生成する、これから入力するファイルの名前である。そこで、今回は以下の様にソースコードを訂正する。

訂正前
```c
  fn = alloc_printf("%s\\.cur_input", out_dir);
  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);
```
訂正後
```c
  fn = alloc_printf("%s\\.cur_input.jww", out_dir);
  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);
```

５種類の拡張子のいずれかであれば問題ない。今回は```jww```拡張子にした。他の２箇所にいついても、同様に修正すれば良い。

### WinAFL.cの修正
最初に、```MessageBoxA```及び```MessageBoxW```と同じ引数と戻り値を持つ無害な関数を定義する。戻り値としては、常に「はい」を押下されたことになる様に、定数値を返すのみにする。

608行辺りに以下を追加する。
```c
static int
messageboxa_interceptor(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
	return IDOK;
}

static int
messageboxw_interceptor(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {
	return IDOK;
}
```

更に、```messageBox```の呼び出しをフックし、上記関数とすり替えるために、740行辺りに以下を追加する。
```c
if (_stricmp(module_name, "USER32.dll") == 0) {
	to_wrap = (app_pc)dr_get_proc_address(info->handle, "MessageBoxW");
	drwrap_replace(to_wrap, (app_pc)messageboxw_interceptor, (bool)NULL);
	to_wrap = (app_pc)dr_get_proc_address(info->handle, "MessageBoxA");
	drwrap_replace(to_wrap, (app_pc)messageboxa_interceptor, (bool)NULL);
}
```
注意点としては、```USER32.dll```は大文字にする必要があることと、```dr_get_proc_address```及び```NULL```は、上記の通りに型変換をしないと、ビルド時に警告を受けることくらいだろう。

### WinAFLの再ビルド
ここまでの修正を完了させたら、再度ビルドを行う。手順としては既に紹介したが、念のために```build32```を消去する。また、今後新たにFuzzingを行うアプリケーションのために、都度これらの修正内容についての技術詳細をドキュメント化すべきであり、業務の属人化を防がなければならない。

### ビルドが終了したら
今までの作業で、Fuzzingに必要な準備の大半は終了した。残すところは```targrt_offset```の選定と、シード（seed：種）ファイルの準備である。どちらも必ずしも１つに絞ることはできないものであり、解析者の腕によりFuzzingそのもののパフォーマンスを大きく作用する重要な技術である。更に、状況に応じてカバレッジ計測対象についても考慮する必要もある。

いずれにせよ、解析者は広く関連する技術分野を理解していなければならないのであって、各分野の背景になる基本的な考え方や原理を蔑ろにはできない。反対に言えば、基礎となる以下の分野をしっかりと抑えていれば、短時間で優秀なFuzzing実務担当者になることができる。

- 計算機科学
- 低レイヤー
- 各種ファイルフォーマットに関する実用的な理解

特に、何らかのファイルフォーマットについて、相応な時間をかけて仕様を調べ、理解した経験があると理想的である。多くの場合、Fuzzingの結果発見された不正な入力は、対象アプリケーションの扱うファイルフォーマット上の些細な特徴に対し、これを処理するアプリケーションの不備を突くことによって不正な動作を引き起こすことになる。そのため、ファイルフォーマットを詳しく調査し、理解した経験は必ず活きる筈である。

## Fuzzing実施のための準備
いよいよFuzzingの実施に取り掛かる。ここからは、実施の上で必要な各種コマンドのオプションを正確に設定する方法について説明する。入念な事前の解析により、対象アプリケーションに併せたWinAFLの修正が済んでいれば、多くの場合、Fuzzingが適切に実行されない原因はオプションの指定方法に誤りがある。また、実施の際は、管理者権限でコマンドプロンプトを立ち上げる必要がある。

### 各種オプション一覧
以下が使用するオプションの一覧であるが、今回の解析で使用するものはこの中の一部である。

コマンドは以下の様に３つの部分により構成されている。

```
afl-fuzz [afl options] -- [instrumentation options] -- target_cmd_line
```

翻訳や加筆は後でやる。訳語はどこかで固定したい。

#### [afl options]
```
-i dir        - テストケース用のinputディレクトリを指定
-o dir        - fuzzerが発見したファイルを格納するoutputディレクトリを指定
-t msec       - 各実行単位（run）の制限時間（これを短く設定し過ぎると、toutが多発するので注意）
-s            - deliver sample via shared memory
-D dir        - DynamoRioのバイナリ（drrun, drconfig）があるディレクトリのパスを指定
-w path       - winafl.dllのパスの指定（通常はafl-fuzz.exeと同じディレクトリにあるので指定不要）
-e            - expert mode to run WinAFL as a DynamoRIO tool
-P            - Intel PT トラッキングモードを使用（CPUがIntel PTに対応している必要がある）
-Y            - 静的計装モードを有効にする
-f file       - 対称が読み込むファイル（動作に最中にあれば）のディレクトリのパスを指定
-m limit      - 対象のプロセスが使用するメモリの上限指定
-p            - persist DynamoRIO cache across target process restarts
-c cpu        - 使用するCPUの指定
-d            - quick & dirty mode (skips deterministic steps)
-n            - 計装なしでFuzzingを実行する(dumb mode)
-x dir        - 追加でFuzzer用の辞書を指定する
-I msec       - timeout for process initialization and first run
-T text       - text banner to show on the screen
-M \\ -S id   - 分散処理モード（詳細は後述）
-C            - crash exploration mode (the peruvian rabbit thing)
-l path       - a path to user-defined DLL for custom test cases processing
-A module     - a module identifying a unique process to attach to
```

#### [instrumentation options]
```
-covtype         - the type of coverage being recorded. Supported options are
                   bb (basic block, default) or edge.
-coverage_module - カバレッジを計測する対象の指定 複数のモジュールを指定可能
                   例：exeに加えてdllを追加指定
-target_module   - Fuzzing対象となる目的関数を擁するモジュールを指定
                   目的関数のシンボル名又はbase addresからのオフセットのいずれかが
		   このオプションと同時に指定されなければならない
-target_method   - name of the method to fuzz in persistent mode. For this to
                   work either the method needs to be exported or the symbols
                   for target_module need to be available. Otherwise use
                   -target_offset instead.
-target_offset   - offset of the method to fuzz from the start of the module.
-fuzz_iterations - 対象プロセスが再スタートするまでに目的関数を実行する回数
-nargs           - 目的関数の引数の数を指定　この引数は保存され、各実行毎に使用される
-call_convention - デフォルトの関数呼び出し規則は32bit x86のcdecl及びVisual Studio
                   64bit向けのMicrosoft x64である
                   指定可能な値の一覧は以下の通り:
                       * fastcall: fastcall
                       * ms64: Microsoft x64 (Visual Studio)
                       * stdcall: cdecl or stdcall
                       * thiscall: thiscall
-debug           - デバッグモード。サーバへの接続は試みない。ロード済みモジュールや、
                   開いたファイル、カバレッジに関する情報等をログ出力する
-logdir          - ログファイルを出力するディレクトリパスの指定
                   (-debug の場合のみに使用)
-thread_coverage - If set, WinAFL will only collect coverage from a thread
                   that executed the target function
```

#### target_cmd_line
今回の場合は以下の例の通りになる。尚、```@@```は入力ファイル等のプレースホルダとなり、```.cor_input```がここに代入される。

```
C:\winafl_for_jwc\build32\bin\Release\JWW\Jw_win.exe @@
```

#### 実行コマンド例
結論から記せば、今回の解析では次の通りのコマンドを実行することになる。

```
afl-fuzz.exe -i input -o C:\winafl_for_jwc\build32\bin\Release\JWW\output -t 10000 -D C:\DynamoRIO8.0.18460\bin32 -- -coverage_module common_lib.dll -coverage_module Jw_win.exe -target_module Jw_win.exe -target_offset 0x0283448 -fuzz_iterations 5000 -nargs 2 -call_convention thiscall -- C:\winafl_for_jwc\build32\bin\Release\JWW\Jw_win.exe @@
```

#### フォルダ等の配置
Cドライブ直下にWinAFL及びDynamoRIO8.0.18460を配置する。また、JWCADのJWWフォルダ及びシードを入れたinputフォルダはともに```C:\winafl\build32\bin\Release```に配置する。更に、JWWフォルダ内には空のoutputファイルを作成する。

### -i
このオプションは、seedファイルを格納するinputフォルダを指定するものである。基本的には```afl-fuzz.exe```と同じ階層に準備すれば良い。内部に入れるseedファイルの選び方については後述する。

### -o
このオプションにより指定されたフォルダには、以下のフォルダとファイルが自動的に作成される。

#### フォルダ
- crashes
- drcache
- hangs
- ptmodules
- queue

#### ファイル
- .cur_input(.jww)
- fuzz_bitmap
- fuzzer_stats
- plot_data

重要なものについてのみ説明する。```crashes```フォルダ内には、メモリアクセス違反等でアプリケーションがクラッシュした場合の入力ファイル（クラッシュファイル）の内、ユニークなものが格納される。また、```hangs```フォルダ内には```-t```で指定した以上の時間、動作が中断した場合の入力ファイル（ハングファイル）を格納する。大抵の場合、それは無限ループを引き起こしてフリーズさせる入力ファイルである。

```.cur_input(.jww)```ファイルについては既に説明しているが、現在入力されているファイルである。これは、```queue```フォルダ内で読み込み待ちをしているファイルから順に呼び出されることになる。

### -t msec
指定した値が、各実行における制限時間となる。単位はミリ秒であり、通常はそれほど大きな値を指定する必要はない。今回は10,000 msec程度で十分である。

### -D dir
DynamoRioのbin32/64ディレクトリのパスを指定する。

### -coverage_module
カバレッジを計測する対象を指定する。今回の場合、```Jw_win.exe```は当然として、併せて```Jw_win.exe```が使用する```common_lib.dll```も追加で指定する。少なくとも前者のみを指定していれば良い。

### -target_module
Fuzzingの対象を指定する。当然、今回の場合は```Jw_win.exe```を指定する。

### -target_offset
対象アプリケーション内のサブルーチン（関数、メソッド）の先頭アドレスを指定する。この値の策定方法は簡単ではないため、別に詳しく説明する。今回の場合は、```0x0283448```を指定する。

### -fuzz_iterations
Fuzzingを高速に実行するために、WinAFLは```-target_offset```で指定した関数で一度スナップショット（レジスタやスタックの値を保存）を撮り、各実行毎にリセットをしてこの地点から実行することで、プロセスを実行毎に丸ごと最初から再起動しなくても良いように工夫されている。しかしながら、完璧にスナップショットを撮っている訳でないため、実行回数が増えるにつれてプロセス内部のメモリ等の中身が変化してしまい、やがて正常に動作しなくなる。

そこで、一定回数の実行毎に動作を最初からリセットさせることで、安定的に動作できるようにしている。```-fuzz_iterations```では、このリセットを実施するまでの回数を指定する。この値は小さい方が動作が安定し、大きくすることで動作を高速化できる。適切な値を事前に決定することは困難であり、解析対象のアプリケーションに依存する。今回は10,000回を採用する。

### -nargs
```-target_offset```で指定した関数の引数の数を指定する。Ghidra等で解析するのが早いが、デバッガを用いて逆アセンブリにより解析する方が確実である。

### -call_convention
```-target_offset```で指定した関数の呼び出し規則を指定する。関数は、一般的に呼び出し規則に応じて戻り値の渡し方等、動作が異なる。そこで、正しい呼び出し規則を指定しないと、スナップショットを元に繰り返し実行することができない。関数の呼び出し規則を調べる方法は多数あるが、Ghidraを使用するのが簡単で良い。各種関数呼び出し規則については、リバースエンジニアリングを行う上で必須の知識なので、この際にしっかりと学ぶべきである。尚、今回の場合は```thiscall```を指定する。

関数呼び出し規則の良い資料があったので、後で追記する。

## seedファイルの選び方
seedファイルはinputディレクトリ内部に準備する、対象に対して入力するファイルの雛形である。WinAFLは、このseedファイルを基に入力するファイルを生成する。そのため、このseedファイルの品質がFuzzingの結果に大きく影響する（参考文献：https://hexhive.epfl.ch/publications/files/21ISSTA2.pdf）。

### seedファイルが備えるべき性質
seedファイルには以下の性質が備わっていることが望ましい。

- 必要最小限のサイズであること
- 複数のseedはそれぞれ直交していること

#### seedの直交とは
あるファイルフォーマットに、特定のファイルオフセットにそれぞれパラメータが割り当てられたとする。例えば、以下のファイルフォーマットを想定してみる。

|オフセット|項目|
|--|--|
|0|ファイルタイプ|
|1～4|ファイルサイズ|
|5～8|フォーマットバージョン|
|9|チェックサム|

この場合、合計で4個の項目が存在する。この時、より直交性の高いseedとは、それぞれのseedのそれぞれの項目が互いに重複していないことである。例えば、このファイルを扱うアプリケーションに、特定のフォーマットバージョンの時に、特定のファイルサイズを指定すると引き起こされる脆弱性があったとする。その場合、この4個の項目に対して満遍なく様々な値を指定したseedを用意した方が、脆弱性を発見するのが短時間で済むことは容易に予想される。

seedの直交性を確保するということは、上記例の様にファイルフォーマットにより定義された各要素を基底とした際に、直交性が高いものを用意することに他ならない。

### Fuzzingコーパス
既に経験上優秀な性能を発揮することが知られているそれぞれのファイルフォーマット用のseedが公開されている。以下は、その代表例である。

- https://github.com/strongcourage/fuzzing-corpus

業務としてFuzzingを行う場合は、経験知として例の様なコーパスを組織として蓄積し、活用できる状態にすべきである。

## -target_offsetの選定方法
WinAFLのソースコード修正に並ぶ難易度であるのが、```-target_offset```つまり目的の関数の決定である。これは、一般的には以下の考え方を用いる。

目的の関数の内部で、以下の動作を行うものとする。

1. 入力ファイルを開く。
2. 入力ファイルをparseする。
3. 入力ファイルを閉じる
4. 関数が```ret```を実行する

条件１は必須である。理由は簡単で、各実行毎に新たに用意された入力ファイルを読み込ませるためである。もしも読み込みが終了した後に呼び出される関数を目的とした場合、その時点でスナップショットを撮られることになり、各実行毎に入力されたファイルを変化させることができなくなる。

条件２も重要であり、入力ファイルをparseする過程でカバレッジを測定することで、効率良く脆弱性を検出できるからだ。そのため、解析対象の実行ファイルに加え、dll等でparseを行っていることが判明したのであれば、当然それも```-coverage_module```に追加すべきである。

条件３も必須である。なぜならば、開いた入力ファイルを閉じなければ、WinAFLがその入力ファイルを別の物に書き換えることができないからである。入力ファイル```.cur_input```を次々と書き換えて脆弱性の検出を行うのがWinAFLの基本動作である。

条件４も必須である。もしも関数内で```ExitProcess()```関数等が実行されて動作が終了した場合、WinAFLは動作の終了を検知することができない。WinAFLは、目的の関数が```return```されるとこれをキャッチし、再度スナップショットを読み込むことで動作を巻き戻す。したがって、関数内部において別の方法で動作が終了してしまうと、関数内部の処理が終了したことを検出できず、```-t```で指定した時間が経過するまで動作が継続してしまう。

### 具体的な目的関数の発見方法
これまでに説明した条件を満たす関数を発見する方法は、ある程度であれば体系化された方法により、手続き的に解決可能である。以下はその手順であるが、前提知識として、関数呼び出しとスタックフレームの構造についての理解が必要である。


#### 以下、WinDBGによる操作

1. CreateFile関数に対してbreak point
2. CloseFile関数に対してbreak point
3. 上記２break時のスタックバックフレームを取得

||||
|--|--|--|
|スタックトップ→|CreateFile||
||Fun_1||
|スタックトップ^→|Fun_2|CloseHandle|
||Fun_3|Fun_A|
||Fun_4|Fun_B|
|目的関数→|Fun_C|Fun_C|
|以下共通↓|Fun_D|Fun_D|
||Fun_E|Fun_E|
||Fun_F|Fun_F|

4. スタックのバックトレースを比較し、共通部分のトップを目的関数として抽出
5. 目的関数の呼び出し元に対してbreak pointを設定し、呼び出し後の```return```を確認

上記手順により、条件２を除いて満たしていることをほぼ機械的に確認できる。複数の候補がある場合は、その全てに対して```Fuzzing```を実施し、正常に実施ができてクラッシュファイルを入手できたものが目的関数である。

### JWCADの目的関数（まだ作りかけで内容も変更予定です）
それでは実際に先に紹介した手順をWinDBGで実施してみる。

今回はWinDBG Preview版ではなく、旧版を利用する。これは、Microsoft Storeを利用できない場合、Preview版を使用することができないからである。その様な組織においてもFuzzingをしなければならないことがあるかも知れないので、いずれの版についてもWinDBGを使いこなして貰いたい。

まずは、画像の通りにJWCADとそれに読み込ませるファイルを指定してデバッグを開始する。

![target_fun1](https://user-images.githubusercontent.com/77034428/158392977-e98a58bd-9ea0-4bd6-b007-221fdbc8a975.jpg)

まずは、```lm```コマンドにより、使用されているモジュール（dll）の一覧を取得する。```CreateFile```及び```CloseHandle```を擁する```KERNEL32```の存在を確認することができたと思う。

![target_fun2](https://user-images.githubusercontent.com/77034428/158392999-5217cc43-11f9-486c-94ed-36436ed842c9.jpg)

次に、```CreateFileW```及び```CloseHandle```の両方の関数呼び出しに対して```bu```コマンドでブレークポイントを設置し、順に```k```コマンドによりスタックのバックトレースを確認する。

```
0:000> k
 # ChildEBP RetAddr      
00 0018a398 007ba8fb     KERNEL32!CreateFileW
WARNING: Stack unwind information not available. Following frames may be wrong.
01 0018a400 007b3cce     Jw_win+0x3ba8fb
02 0018a42c 007b3c3f     Jw_win+0x3b3cce
03 0018a484 007b3cfb     Jw_win+0x3b3c3f
04 0018a4a4 007a9397     Jw_win+0x3b3cfb
05 0018a4d4 0079684b     Jw_win+0x3a9397
06 0018a518 00796885     Jw_win+0x39684b
07 0018a52c 004c4d9c     Jw_win+0x396885
08 001927b0 00489e15     Jw_win+0xc4d9c
09 00199024 0068355e     Jw_win+0x89e15
0a 001990b4 0068b9d9     Jw_win+0x28355e
0b 001990e4 006a04d4     Jw_win+0x28b9d9
0c 00199424 006a0301     Jw_win+0x2a04d4
0d 00199434 0049967e     Jw_win+0x2a0301
0e 0019fa58 0068ae55     Jw_win+0x9967e
0f 0019fa80 00490c0c     Jw_win+0x28ae55
10 0019ff10 007bcfe4     Jw_win+0x90c0c
11 0019ff24 0079baee     Jw_win+0x3bcfe4
12 0019ff70 75d7fa29     Jw_win+0x39baee
13 0019ff80 77657a7e     KERNEL32!BaseThreadInitThunk+0x19
14 0019ffdc 77657a4e     ntdll!__RtlUserThreadStart+0x2f
15 0019ffec 00000000     ntdll!_RtlUserThreadStart+0x1b
```
４回（注：後でちゃんと確かめる）```g```及び```k```コマンドを実施すると、上記の様なスタックトレースになる。また、同様に```CloseHandl```にブレークポイントを設置し、２回（注：これも確かめる）実行すると、

```
0:000> k
 # ChildEBP RetAddr      
00 00199014 00683d95     KERNEL32!CloseHandle
WARNING: Stack unwind information not available. Following frames may be wrong.
01 00199020 00683572     Jw_win+0x283d95
02 001990b4 0068b9d9     Jw_win+0x283572
03 001990e4 006a04d4     Jw_win+0x28b9d9
04 00199424 006a0301     Jw_win+0x2a04d4
05 00199434 0049967e     Jw_win+0x2a0301
06 0019fa58 0068ae55     Jw_win+0x9967e
07 0019fa80 00490c0c     Jw_win+0x28ae55
08 0019ff10 007bcfe4     Jw_win+0x90c0c
09 0019ff24 0079baee     Jw_win+0x3bcfe4
0a 0019ff70 75d7fa29     Jw_win+0x39baee
0b 0019ff80 77657a7e     KERNEL32!BaseThreadInitThunk+0x19
0c 0019ffdc 77657a4e     ntdll!__RtlUserThreadStart+0x2f
0d 0019ffec 00000000     ntdll!_RtlUserThreadStart+0x1b
```

となる。

```0068b9d9```はスタック上のリターンアドレスであるが、以下のアセンブリコードを見ると、

```
0068b9c9 8945ec          mov     dword ptr [ebp-14h],eax
0068b9cc ff5264          call    dword ptr [edx+64h]
0068b9cf 8b17            mov     edx,dword ptr [edi]
0068b9d1 8bcf            mov     ecx,edi
0068b9d3 ff7508          push    dword ptr [ebp+8]
0068b9d6 ff527c          call    dword ptr [edx+7Ch]
0068b9d9 85c0            test    eax,eax
0068b9db 7548            jne     Jw_win+0x28ba25 (0068ba25)
0068b9dd 3945f0          cmp     dword ptr [ebp-10h],eax
0068b9e0 7409            je      Jw_win+0x28b9eb (0068b9eb)
0068b9e2 8b03            mov     eax,dword ptr [ebx]
0068b9e4 8bcb            mov     ecx,ebx
0068b9e6 ff5060          call    dword ptr [eax+60h]
0068b9e9 eb29            jmp     Jw_win+0x28ba14 (0068ba14)
0068b9eb 8b07            mov     eax,dword ptr [edi]
0068b9ed 8bcf            mov     ecx,edi
0068b9ef ff5060          call    dword ptr [eax+60h]
0068b9f2 85c0            test    eax,eax
0068b9f4 750c            jne     Jw_win+0x28ba02 (0068ba02)
0068b9f6 8b07            mov     eax,dword ptr [edi]
0068b9f8 8bcf            mov     ecx,edi
0068b9fa ff75ec          push    dword ptr [ebp-14h]
```

直前の```0068b9d6 ff527c          call    dword ptr [edx+7Ch]```に対してブレークポイントを設置し、ステップイン実行をかければ良いことが分かる。

```
00683445 40              inc     eax
00683446 5e              pop     esi
00683447 c3              ret
00683448 6a68            push    68h
0068344a b85d157e00      mov     eax,offset Jw_win+0x3e155d (007e155d)
0068344f e8ca871100      call    Jw_win+0x39bc1e (0079bc1e)
00683454 8bf9            mov     edi,ecx
00683456 897de0          mov     dword ptr [ebp-20h],edi
00683459 8b5d08          mov     ebx,dword ptr [ebp+8]
0068345c 33c0            xor     eax,eax
0068345e 85db            test    ebx,ebx
00683460 0f95c0          setne   al
00683463 85c0            test    eax,eax
00683465 7505            jne     Jw_win+0x28346c (0068346c)
00683467 e84877feff      call    Jw_win+0x26abb4 (0066abb4)
0068346c 6a14            push    14h
0068346e e87076feff      call    Jw_win+0x26aae3 (0066aae3)
00683473 59              pop     ecx
00683474 8945e4          mov     dword ptr [ebp-1Ch],eax
00683477 33c9            xor     ecx,ecx
00683479 894dfc          mov     dword ptr [ebp-4],ecx
```

結果、上記の様に```00683448 6a68            push    68h```に処理が移る。これが目的関数のアドレスの候補になる。

ここで重要なのは、この目的関数の呼び出し規則である。これは、```-call_convention```で指定する必要がある。指定可能な組み合わせは以下の通りである。

- fastcall: fastcall
- ms64: Microsoft x64 (Visual Studio)
- stdcall: cdecl or stdcall
- thiscall: thiscall

呼び出し規則を確定する最も簡単な方法は、Ghidraにより該当アドレスの関数を調べることである。また、関数呼び出し規則については以下の文献が詳しい。

[x86/x86_64関数呼び出しチートシート](https://raw.githubusercontent.com/sunnyone/docs/b2eab54f60bf6295ceda470e1cb400fd6764dd43/x86-x86-64-function-cheat-sheet/x86-x86-64-function-cheat-sheet.pdf)

## Fuzzingの実施
これまでに解説した通りに、```afl-fuzz```の実行コマンドは３つの部分で構成されている。各部分を適切に設定できたのなら、それらを```--```により結合する。今回の場合は以下の通りになる筈である。

```
afl-fuzz.exe -i input -o C:\winafl_for_jwc\build32\bin\Release\JWW\output -t 10000 -D C:\DynamoRIO8.0.18460\bin32 -- -coverage_module common_lib.dll -coverage_module Jw_win.exe -target_module Jw_win.exe -target_offset 0x0283448 -fuzz_iterations 5000 -nargs 2 -call_convention thiscall -- C:\winafl_for_jwc\build32\bin\Release\JWW\Jw_win.exe @@
```

これを、管理者権限で立ち上げたたコマンドプロンプトで実行すれば良い。実行の際は、コマンドプロンプトのカレントディレクトリを```afl-fuzz.exe```のある、```C:\winafl\build32\bin\Release```に移動することも忘れてはいけない。

### 実行時の画面
```afl-fuzz.exe```を無事に実行すると、以下の様な画面が表示される。

![aflfuzz1](https://user-images.githubusercontent.com/77034428/158392793-b7c7a492-546d-476a-adb6-aed0e3aec1cc.jpg)

各項目について順に説明する。

![process_timing](https://user-images.githubusercontent.com/77034428/159189018-67995e20-d775-4605-8e07-943d1ff93c12.PNG)

|process timing|時刻情報|
|:---|:---|
|run time|実行開始からの経過時間|
|last new path|新しいpath（カバレッジを拡大するような新しい実行経路を含むテストケースのこと）を発見してからの経過時間|
|last uniq crash|新しいcrashファイル発見からの経過時間|
|last uniq hang|新しいhangファイル発見からの経過時間|

これらの項目は全て、何らかの経過時間を表示している。大抵の場合、Fuzzingは数日から数週間、更に数か月を要することもある。また、last new pathが開始後数分しても表示されない場合、何らかの原因で正常に動作していない。その場合、時刻情報の代わりに```none yet  (odd, check syntax!)```という警告が表示される。

![overall_results](https://user-images.githubusercontent.com/77034428/159190184-40b90897-853a-49bb-abc7-589528d02b15.PNG)

|overall results|総合結果|
|:---|:---|
|cycles done|サイクル完了数|
|total paths|合計パス|
|uniq crashes|ユニーククラッシュ|
|uniq hangs|ユニークハング|

cycles doneは、それまでに発見された興味深いテストケース全てを実行した回数である。もし、この値が0であれば、Fuzzerは依然として全テストケースを終了していないのであり、少なくとも一度は終了させるべきである。また、最初の１回を終了させるには通常数日は要する。

![cycle_progress](https://user-images.githubusercontent.com/77034428/159190780-64450347-ad70-49dc-b45e-e96917ff2283.PNG)

|cycle progress|サイクル進捗状況|
|:---|:---|
|now processing|現進捗状況|
|paths timed out|不明（記述なし？）|

now processingは、現在のqueueサイクルの進捗状況である。この進捗が遅い場合は、```-d```オプションの仕様を検討するか、より高性能な計算機を用意すべきである。

画像：未作成

|map coverage|マップカバレッジ|
|:---|:---|
|map density|不明|
|count coverage|不明|

map densityが200以下の場合、以下の可能性があるため注意が必要である。

- 対象のアプリケーションが極端に単純である
- 適切に計装されていない（target library以外で処理が行われている）
- 入力が与えられてすぐにプログラムが停止している

また、パーセントが70%を超えることは、テンプレート化されたコードで成り立つ複雑なアプリケーションでは滅多に起こらない。

以降、未翻訳部分

Because high bitmap density makes it harder for the fuzzer to reliablydiscern new program states, I recommend recompiling the binary withAFL_INST_RATIO=10 or so and trying again (see env_variables.txt).

The fuzzer will flag high percentages in red. Chances are, you will neversee that unless you're fuzzing extremely hairy software (say, v8, perl,ffmpeg).

The other line deals with the variability in tuple hit counts seen in thebinary. In essence, if every taken branch is always taken a fixed number of
times for all the inputs we have tried, this will read "1.00". As we manageto trigger other hit counts for every branch, the needle will start to move
toward "8.00" (every bit in the 8-bit map hit), but will probably neverreach that extreme.

Together, the values can be useful for comparing the coverage of severaldifferent fuzzing jobs that rely on the same instrumented binary.

ここまで

|stage progress|ステージ進捗状況|
|:---|:---|
|now truing|現選択戦略|
|stage execs|現戦略実行回数|
|total execs|総実行回数|
|execs speed|実行速度|



|fuzzng strategy yields|Fuzzing戦略収率表|
|:---|:---|
|bit flips|bit反転|
|byte flips|byte反転|
|arithmetics||
|known ints||
|dictionary|辞書|
|havoc|複合|
|trim||

|findings in depth||
|:---|:---|
|favored paths||
|new edges os||
|total crashes|合計クラッシュ数|
|total tmouts|合計時間切れ数|

|path geometry||
|:---|:---|
|levels||
|pending|byte反転|
|pend fav||
|own finds||
|imported|他プロセスからの移設数|
|stability|安定度|

- cpu稼働率

各パラメータの詳細や、判断事項についてはいつか加筆する

## 並列Fuzzingの実施
複数のコアを使用できるFuzzing端末であれば、利用可能なスレッド数を上限として、並列動作させることができる。WinAFLでは、マスタ（Master）と呼ばれるプロセス１個と、セカンダリ（Secondary）と呼ばれる複数のプロセスが協調して解析することになる。この際、マスタが発見したユニークなクラッシュファイルをセカンダリプロセスが受け取り、主にhavoc戦略等によりFuzzingを実行する。

### 実行コマンド例

#### マスタ（Master）
```
afl-fuzz.exe -i input -o C:\winafl\build32\bin\Release\JWW\output -M output_M -t 10000 -D C:\DynamoRIO8.0.18460\bin32 -- -coverage_module common_lib.dll -coverage_module Jw_win.exe -target_module Jw_win.exe -target_offset 0x0283448 -fuzz_iterations 5000 -nargs 2 -call_convention thiscall -- C:\winafl\build32\bin\Release\JWW\Jw_win.exe @@
```

#### セカンダリ（Secondary）
```
afl-fuzz.exe -i input -o C:\winafl\build32\bin\Release\JWW\output -S output_S1 -t 10000 -D C:\DynamoRIO8.0.18460\bin32 -- -coverage_module common_lib.dll -coverage_module Jw_win.exe -target_module Jw_win.exe -target_offset 0x0283448 -fuzz_iterations 5000 -nargs 2 -call_convention thiscall -- C:\winafl\build32\bin\Release\JWW\Jw_win.exe @@
```

### 指定オプション
単体のFuzzingに追加する形で、並列Fuzzingでは複数のオプションを指定する必要がある。また、ディレクトリ構成も変更する必要がある。

#### -M
マスタプロセスのみに指定するのが、```-M```オプションである。ここで指定するのは個別の出力フォルダ名であり、例えば```-M output_M```とした場合は```-o```オプションで指定した```output```フォルダ内に```output_M```というフォルダが生成される。そして、このフォルダ内部には、単体Fuzzingのoutputフォルダと同様のフォルダおよびファイルが生成される。

#### -S
セカンダリプロセスについても、マスタプロセスの```-M```オプションと同様に```-S```オプションを指定する。内容と各構成も同様なので、説明は省く。

## 結果の解析
Fuzzingを実行し、いくつかのクラッシュファイルが入手出来たら、脆弱性を発見したことになる。しかし、この時点では、具体的な原因までは明らかではない。最も簡単な方法は、アプリケーションの開発元に再現性を確認したクラッシュファイルやハングファイルを提出し、修正を依頼するのが良いだろう。しかしながら、開発元に様々な事情で連絡が取れない場合もあるだろうし、仮に連絡を取ることができたとしても、ある程度まではこちらで原因を解析し、修正案を示す方が好ましい。また、発見した脆弱性が深刻な場合、具体的には任意コード実行が可能な場合は、安易に開発元に修正をするよりも、具体的な攻撃手段として蓄積したい場合もあるはずだ。

本解析では、攻撃コード作成までは例示しないが、WinDBGによりクラッシュが引き起こされる瞬間までを追う過程を体験してもらう。そのため、具体的な原因を解析することはしない。原因の解析にせよ、攻撃コードの作成にせよ、高度な技術が必要であることは間違いないので、ここでは参考文献を示すだけに留める。

参考文献はそのうち

### WinDBGの準備
WinDBGには従来のものと、2017年以来公表されているPreview版がある。Preview版は依然開発途中であり、度々機能強化が行われているが、これまでのものと比較して、GUIとしての機能強化がなされている。しかしながら、Microsoft Storeでのダウンロードのみ対応しているため、スタンドアロン端末では利用できない。旧バージョンのものは、Windows SDKの一部として公開されており、ISOファイルとしてスタンドアロン端末にもインストールすることができる。

![windbg](https://user-images.githubusercontent.com/77034428/158392647-733b40bd-a76b-4a6b-8d90-b8589e350a7c.jpg)

### WinDBG Preview版の操作法
これまでにIDA等の商用デバッガを使用した経験のある者もいるだろうが、これと比較するとWinDBGは硬派な使用感である。基本的にはコマンドラインにより操作する必要があり、覚えることも少なからずある。本解説の目的は、Windowsアプリケーションに対するFuzzingを最低限一通り体験することであって、デバッガの詳細な使用方法や理論については触れない。

### プロセスの起動
WinDBG Preview版であれば、Time Travel Debugging（TTD）機能が便利である。これは、プロセスの実行を記録し、自由に実行ステップを魚ぼって様々な検証を行うことができる。これにより、クラッシュした時点からレジスタやスタック内部の値を観察することができるため、従来の方法よりも短時間で解析を進めることができる。業務としてFuzzingを行うのであれば、この機能を使わない手はない。

![windbg1](https://user-images.githubusercontent.com/77034428/158392560-35c4d048-0c67-4a48-af86-b8a6f01e1ef2.jpg)

まずは、```FIle```→```Start debugging```→```Launche executable(advanced)```を選択し、画像の通り、```Executable```と```Aruguments```を指定する。```Arguments```には、これまでのFuzzingで発見した```output```→```craches```フォルダ内のクラッシュファイルを指定する。準備が完了したら、```Record with Time Travel Dubugging```にチェックを入れ、```Configure and Record```をクリックする。その後、記録ファイルの保存場所を尋ねられるので、適切に指定し```Record```を押下する。

### クラッシュ地点の確認
デバッグを開始したら、以下の様に自動的に```INT 3```によりブレークされることになる。今回はクラッシュする瞬間を確認するのが目的なので、```g```コマンドによりそのまま実行を継続させる。

![windbg2](https://user-images.githubusercontent.com/77034428/158392463-e41e005c-6ad7-4942-ac46-5091a750d4b1.jpg)

また、この状態で```k```コマンドを使用すると、スタックのバックトレースを確認できる。

```
0:000> k
 # ChildEBP RetAddr      
WARNING: Stack unwind information not available. Following frames may be wrong.
00 000dac04 004f66a8     Jw_win+0xecda2
01 001927b8 00489eb7     Jw_win+0xf66a8
02 00199024 0068355e     Jw_win+0x89eb7
03 001990b4 0068b9d9     Jw_win+0x28355e
04 001990e4 006a04d4     Jw_win+0x28b9d9
05 00199424 006a0301     Jw_win+0x2a04d4
06 00199434 0049967e     Jw_win+0x2a0301
07 0019fa58 0068ae55     Jw_win+0x9967e
08 0019fa80 00490c0c     Jw_win+0x28ae55
09 0019ff10 007bcfe4     Jw_win+0x90c0c
0a 0019ff24 0079baee     Jw_win+0x3bcfe4
0b 0019ff70 75d7fa29     Jw_win+0x39baee
0c 0019ff80 77657a7e     KERNEL32!BaseThreadInitThunk+0x19
0d 0019ffdc 77657a4e     ntdll!__RtlUserThreadStart+0x2f
0e 0019ffec 00000000     ntdll!_RtlUserThreadStart+0x1b
```

ここからが、本当の意味で本題である。しかしながら、なぜこの様なアクセス違反が発生したのか、本質的な意味でその原因を追うのは困難な作業である。ましてこの脆弱性の原因を完璧に理解し、それによりRCEを成し遂げる様なExploitコードを作成するのは至難の業であり、多くの技術を学ぶ必要がある。

果てしない道のりだが、脆弱性の原因についてそれを調べる困難な作業を少しでも楽に行うためにTime Travel Debugging機能がある。使用できる機能は様々だが、最も分かりやすい方法は、```p```であれば```p-```、```g```であれば```g-```の様に、マイナスを付ければ逆向きに実行できる。

# 参考文献
- 実践バイナリ解析 バイナリ計装、解析、逆アセンブリのためのLinuxツールの作り方 (no starch press) 単行本 – 2022/1/29
- Windowsダンプの極意 エラーが発生したら、まずダンプ解析! 大型本 – 2008/11/27
- [The Fuzzing Book](https://www.fuzzingbook.org/)
