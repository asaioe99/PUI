# 解析メモ
まずは、```g```によりクラッシュした瞬間まで進める。

```
0:000> g
(5ce4.160c): Access violation - code c0000005 (first/second chance not available)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
Time Travel Position: 30145:0
eax=010d2f98 ebx=001927d8 ecx=010dfdd8 edx=0018c39c esi=010dfdd8 edi=00000001
eip=01075e3b esp=0018c36c ebp=0018c370 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
01075e3b 01982f0d0103    add     dword ptr [eax+3010D2Fh],ebx ds:002b:040e3cc7=????????
```

Access違反で落ちている。```ptr [eax+3010D2Fh]=040e3cc7=????????```への```add```が直接の原因らしい。

周辺をアセンブリで読むと、

```
01075e38 c00001         rol     byte ptr [eax], 1           ds:002b:010d2f98=38
01075e3b 01982f0d0103   add     dword ptr [eax+3010D2Fh], ebx
01075e41 0200           add     al, byte ptr [eax]
01075e43 06             push    es
01075e44 61             popad   
01075e45 7261           jb      01075ea8
01075e47 6200           bound   eax, qword ptr [eax]
01075e49 26637972       arpl    word ptr es:[ecx+72h], di
01075e4d 6c             ins     byte ptr es:[edi], dx
01075e4e 007e67         add     byte ptr [esi+67h], bh
01075e51 656f           outs    dx, dword ptr gs:[esi]
01075e53 7200           jb      01075e55
01075e55 8c6865         mov     word ptr [eax+65h], gs
01075e58 627200         bound   esi, qword ptr [edx]
01075e5b 9a6c61746e00a6 call    A600:6E74616C
01075e62 7468           je      01075ecc
01075e64 61             popad   
01075e65 6900c4001c00   imul    eax, dword ptr [eax], 1C00C4h
01075e6b 0446           add     al, 46h
01075e6d 41             inc     ecx
01075e6e 52             push    edx
01075e6f 2000           and     byte ptr [eax], al
01075e71 284d4c         sub     byte ptr [ebp+4Ch], cl

以下略
```

確証はないが、text領域ではないし、正規の命令にも見えない。

そこでASCIIで見てみると、

```
0:000> dc 01075e38
01075e38  010100c0 010d2f98 06000203 62617261  ...../......arab
01075e48  79632600 7e006c72 726f6567 65688c00  .&cyrl.~geor..he
01075e58  9a007262 6e74616c 6874a600 c4006961  br..latn..thai..
01075e68  04001c00 20524146 4c4d2800 34002059  ....FAR .(MLY .4
01075e78  20444e53 52554000 4c002044 ffff0000  SND .@URD .L....
01075e88  00000300 10000500 ffff0000 01000300  ................
01075e98  11000600 ffff0000 02000300 12000700  ................
01075ea8  ffff0000 03000300 13000800 ffff0000  ................
```

言語名の様なものが伺えるため、何らかの文字列である。

そもそも、現在の実行アドレス（EIP）は一体どこなのだろうか。確認してみるべきだ。

```
0:000> !address eip
Address 01075e3b could not be mapped in any of the available regions
```

やはり分からない。不明なアドレスである。

念のために、当該加算先のアドレスを確認する。

```
0:000> dc 040e3cc7
040e3cc7  ???????? ???????? ???????? ????????  ????????????????
040e3cd7  ???????? ???????? ???????? ????????  ????????????????
040e3ce7  ???????? ???????? ???????? ????????  ????????????????
040e3cf7  ???????? ???????? ???????? ????????  ????????????????
040e3d07  ???????? ???????? ???????? ????????  ????????????????
040e3d17  ???????? ???????? ???????? ????????  ????????????????
040e3d27  ???????? ???????? ???????? ????????  ????????????????
040e3d37  ???????? ???????? ???????? ????????  ????????????????
```

アドレスの情報も見てみる。

```
0:000> !address 040e3cc7

                                     
Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...
Address 040e3cc7 could not be mapped in any of the available regions
```

残念ながら何も分からない。

ここで、```t-```により、一個前のコードに戻る。

```
0:000> t-
Time Travel Position: 30144:68
eax=010d2f98 ebx=001927d8 ecx=010dfdd8 edx=0018c39c esi=010dfdd8 edi=00000001
eip=01075e38 esp=0018c36c ebp=0018c370 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
01075e38 c00001          rol     byte ptr [eax],1           ds:002b:010d2f98=38
```

更に進めると、

```
0:000> t-
Time Travel Position: 30144:67
eax=010d2f98 ebx=001927d8 ecx=010dfdd8 edx=0018c39c esi=010dfdd8 edi=00000001
eip=006784eb esp=0018c370 ebp=0018c370 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
Jw_win+0x2784eb:
006784eb ff10            call    dword ptr [eax]      ds:002b:010d2f98=01075e38
```
```
006784e2 55             push    ebp
006784e3 8bec           mov     ebp, esp
006784e5 85c9           test    ecx, ecx
006784e7 7410           je      Jw_win+0x2784f9 (006784f9)
006784e9 8b01           mov     eax, dword ptr [ecx]
006784eb ff10           call    dword ptr [eax]      ds:002b:010d2f98=01075e38
006784ed 85c0           test    eax, eax
006784ef 7408           je      Jw_win+0x2784f9 (006784f9)
006784f1 8bc8           mov     ecx, eax
006784f3 5d             pop     ebp
006784f4 e9bfffffff     jmp     Jw_win+0x2784b8 (006784b8)
006784f9 e8b626ffff     call    Jw_win+0x26abb4 (0066abb4)
006784fe cc             int     3
006784ff 8bc1           mov     eax, ecx
00678501 c20400         ret     4
```

となる。関数として呼び出されたのだ。

呼び出し元では、```006784eb ff10           call    dword ptr [eax] ```を実行し、不明なアドレスへ飛んでしまったのだろう。

## eaxを追う
ここまでの調査で、eaxの値が不正であったため、あり得ないアドレスを```call```したのだろう。そこで、```eax=010d2f98```がどこから来たのかを追う。

直前に、```006784e9 8b01           mov     eax, dword ptr [ecx]```を行い、```ecx=010dfdd8```を参照している。

早速調べると、

```
0:000> dc ecx
010dfdd8  010d2f98 01019b78 00000000 00000000  ./..x...........
010dfde8  00000000 c08f4000 00000000 00000000  .....@..........
010dfdf8  00000000 c08f4000 00020001 00000001  .....@..........
010dfe08  00000000 00000000 00000000 00000000  ................
010dfe18  00000001 00000000 00000000 00000000  ................
010dfe28  00000000 00000002 00000000 00000000  ................
010dfe38  00000000 00000000 00000000 00000000  ................
010dfe48  00000000 00000000 00000000 00000000  ................
```
```
0:000> !address ecx

                                     
Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...
Address 010dfdd8 could not be mapped in any of the available regions
```

ここも何のアドレスか不明である。

そこで、このアドレスに```010d2f98```を書き込んだ瞬間を調べてみる。

```
0:000> ba w 4 010dfdd8
0:000> g-
Breakpoint 0 hit
Time Travel Position: 30143:380
eax=010d2f98 ebx=010d2f90 ecx=01075e38 edx=010dfdd8 esi=01075e38 edi=01010000
eip=770b8adb esp=0018c180 ebp=0018c2a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
ntdll!RtlpFreeHeap+0xeeb:
770b8adb 894104          mov     dword ptr [ecx+4],eax ds:002b:01075e3c=010dfdd8
```

前後のアセンブリは、

```
770b8ac8 8945b4       mov     dword ptr [ebp-4Ch], eax
770b8acb 8b5104       mov     edx, dword ptr [ecx+4]
770b8ace 8b32         mov     esi, dword ptr [edx]
770b8ad0 3bf1         cmp     esi, ecx
770b8ad2 750c         jne     ntdll!RtlpFreeHeap+0xef0 (770b8ae0)
770b8ad4 8908         mov     dword ptr [eax], ecx
770b8ad6 895004       mov     dword ptr [eax+4], edx
770b8ad9 8902         mov     dword ptr [edx], eax
770b8adb 894104       mov     dword ptr [ecx+4], eax ds:002b:01075e3c=010dfdd8
770b8ade eb10         jmp     ntdll!RtlpFreeHeap+0xf00 (770b8af0)
770b8ae0 6a00         push    0
770b8ae2 56           push    esi
770b8ae3 6a00         push    0
770b8ae5 51           push    ecx
770b8ae6 33d2         xor     edx, edx
770b8ae8 8d4a0d       lea     ecx, [edx+0Dh]
770b8aeb e80c060b00   call    ntdll!RtlpLogHeapFailure (771690fc)
```

である。

いつも通り、取り敢えずここがどこかも調べよう。

```
0:000> !address eip

                                     
Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...
Address 770b8adb could not be mapped in any of the available regions
```

残念ながら不明である。

そこでスタック単位で観察してみる。

```
0:000> kb
 # ChildEBP RetAddr      Args to Child              
00 0018c2a8 770fe721     010d2f90 010d3090 010d3090 ntdll!RtlpFreeHeap+0xeeb
01 0018c304 770b7b86     00000000 00000000 00000000 ntdll!RtlpFreeHeapInternal+0x757
02 0018c324 00794d8b     01010000 00000000 010d3090 ntdll!RtlFreeHeap+0x46
WARNING: Stack unwind information not available. Following frames may be wrong.
03 0018c338 00453727     010d3090 010d3090 0018c364 Jw_win+0x394d8b
04 0018c348 00430ce2     00000001 010d3090 ffffffff Jw_win+0x53727
05 0018c364 00441e3d     00000000 010ebb00 010d3090 Jw_win+0x30ce2
06 001927b8 0048a005     010ebb00 00000001 660e2958 Jw_win+0x41e3d
07 00199028 0068355e     00199044 660e29c8 01063360 Jw_win+0x8a005
08 001990b8 0068b9d9     00199320 660e2998 01011560 Jw_win+0x28355e
09 001990e8 006a04d4     00199320 00000001 00000001 Jw_win+0x28b9d9
0a 00199428 006a0301     01022fb0 00000001 0019fa5c Jw_win+0x2a04d4
0b 00199438 0049967e     01022fb0 660e432c 0089cad8 Jw_win+0x2a0301
0c 0019fa5c 0068ae55     01022fb0 660e43f4 ffffffff Jw_win+0x9967e
0d 0019fa84 00490c0c     0019faa0 660e4664 ffffffff Jw_win+0x28ae55
0e 0019ff14 007bcfe4     0079b9e7 0000000a 00000000 Jw_win+0x90c0c
0f 0019ff28 0079baee     00400000 00000000 01016b67 Jw_win+0x3bcfe4
10 0019ff74 75726739     00278000 75726720 0019ffdc Jw_win+0x39baee
11 0019ff84 770d8e7f     00278000 a82a9cd3 00000000 KERNEL32!BaseThreadInitThunk+0x19
12 0019ffdc 770d8e4d     ffffffff 77108cb0 00000000 ntdll!__RtlUserThreadStart+0x2b
13 0019ffec 00000000     0079b9e7 00278000 00000000 ntdll!_RtlUserThreadStart+0x1b
```
どうやら、ヒープ領域の解放の際に何か問題が起きたみたいである。

## RtlpFreeHeapとは？
まずは見出しの関数について調べてみるが、詳しいドキュメントがない。代わりに１個下に似た名前の```RtlpFreeHeapInternal```が他にもあったので、こちらも調べてみたが、詳細が分からなかった。

しかしながら、２個下のフレームの良く似た名前の関数を調べてみると詳細が公開されていた。

```c++
BOOLEAN RtlFreeHeap(
  _In_     PVOID HeapHandle,
  _In_opt_ ULONG Flags,
  _In_     PVOID HeapBase
);
```
```Rtlcreateheap```で取得した```HeapHandle```を指定することで、確保したヒープ領域を解放することができるそうである。

```c++
NTSYSAPI PVOID RtlCreateHeap(
  [in]           ULONG                Flags,
  [in, optional] PVOID                HeapBase,
  [in, optional] SIZE_T               ReserveSize,
  [in, optional] SIZE_T               CommitSize,
  [in, optional] PVOID                Lock,
  [in, optional] PRTL_HEAP_PARAMETERS Parameters
);
```

また、```HeapBase```は```RtlAllocateHeap```により取得されるそうである。

```c++
NTSYSAPI PVOID RtlAllocateHeap(
  [in]           PVOID  HeapHandle,
  [in, optional] ULONG  Flags,
  [in]           SIZE_T Size
);
```
ここからは、WindowsにおけるHeapの仕組みについて理解する必要がある。

